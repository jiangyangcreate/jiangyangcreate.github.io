

## re 模块 （正则表达式）

正则表达式作为多编程语言中的数据匹配工具，实用又简单，预计学习时长 8 小时。这里送上学习笔记和思维导图。

<MarkmapHooks initialMarkdown={`

# 正则表达式

## 概括字符集

### \\d：表示该位置上的字符是数字，即匹配成功
- 等价于[0-9]
### \\D：表示该位置上的字符不是数字，即匹配成功
- 等价于[^0-9]
### \\w：使用(flags=re.ASCII)表示该位置上的字符是_或字母、数字，即匹配成功
- 等价于[a-zA-Z0-9_]
### \\W：使用(flags=re.ASCII)表示该位置上的字符不是_或字母、数字，即匹配成功
- 等价于[^a-zA-Z0-9_]
### \\s：表示该位置上是不可见字符(空格、制表符\\t、垂直制表符\\v、回车符\\r、换行符\\n、换页符\\f)，即匹配成功
- 等价于[\\n\\t\\r\\f\\v]
### \\S：表示该位置上不是不可见字符，即匹配成功

## 数量词

### {3}：表示前面的一个字符出现3次
### {3,8}：表示前面的一个字符出现3-8次
### ?：表示前面的一个字符出现0次或1次
### +：表示前面的一个字符出现1次或无限多次
### *：表示前面的一个字符出现0次或无限多次

## 边界匹配符

### ^：表示只要是以后面的字符开头的，即匹配成功
### $：表示只要是以前面的字符结尾的，即匹配成功
### .：表示一个除换行符\n以外的所有字符
### \\b：匹配一个单词边界，也就是指单词和空格间的位置。例如，'er\b' 可以匹配"never"中的'er'，但不能匹配"verb" 中的'er'。
### \\B：匹配非单词边界。'er\B'能匹配"verb"中的er'，但不能匹配"never" 中的'er'。

## 元字符

### [a-z]：表示该位置上的字符在a-z之间，即匹配成功
### [^a-z]：表示该位置上的字符不在a-z之间，即匹配成功
### [abf]：表示该位置上的字符为a或者b或者f，即匹配成功
- result = re.findall('a[de]c', target)

## 修饰符

### re.I：使匹配对大小写不敏感
### re.L：做本地化识别(locale-aware)匹配
### re.M：多行匹配，影响 ^和$
### re.S：使.匹配包括换行在内的所有字符
### re.U：根据Unicode字符集解析字符。这个标志影响\w, \W, \b, \B.
### re.X：该标志通过给予你更灵活的格式以便你将正则表达式写得更易于理解。

## 匹配

### re.findall(pattern, string, flags=0)

- 如果匹配到就返回一个列表，没有匹配到就返回空列表。

### re.finditer(pattern, string, flags=0)

- 和 findall 类似，在字符串中找到正则表达式所匹配的所有子串，并把它们作为一个迭代器返回。

### re.match(pattern, string, flags=0)

- pattern: 匹配的正则表达式
- string: 要匹配的字符串
- flags: 标志位，用于控制正则表达式的匹配方式，如是否区分大小写，多行匹配等等。参见:正则表达式修饰符中可选标志
- re.match只匹配字符串的开始，如果字符串开始不符合正则表达式，则匹配失败，函数返回None


## 组

### (\\d+)

- ()内的内容构成一个组，只要当前位置满足\d+就匹配成功，返回()内匹配成功的内容

### group(num=0)

- 匹配的整个表达式的字符串，group() 可以一次输入多个组号，在这种情况下它将返回一个包含那些组所对应值的元组。

### group()

- 返回一个包含所有小组字符串的元组，从1到 所含的小组号。


## 检索和替换

### re.search(pattern, string, flags=0)
- pattern: 匹配的正则表达式
- string: 要匹配的字符串
- flags: 标志位，用于控制正则表达式的匹配方式，如是否区分大小写，多行匹配等等。参见:正则表达式修饰符中可选标志
- re.search匹配整个字符串，直到找到一个匹配。

### re.sub(pattern, repl, string, count=0, flags=0)

- pattern: 正则中的模式字符串。
- repl: 替换的字符串，也可为一个函数。
- string: 要被查找替换的原始字符串。
- count: 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。

## 编译正则表达式

### re.compile(pattern[, flags])
- pattern: 一个字符串形式的正则表达式
- flags: 可选，表示匹配模式，比如忽略大小写，多行模式等，具体参数为：re.I, re.M
- compile 函数用于编译正则表达式，生成一个正则表达式(Pattern)对象，供match()和 search() 这两个函数使用。

## 正则分割

### re.split(pattern, string[, maxsplit=0, flags=0])

- pattern: 正则中的模式字符串。
- string: 要匹配的字符串。
- maxsplit: 分隔次数，maxsplit=1 分隔一次，默认为 0，不限制次数。
- flags: 标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。

## 贪婪和非贪婪

### 贪婪模式就是尽可能多地去匹配字符

### 非贪婪模式就是尽可能少地去匹配字符，python默认采取的是贪婪模式。

`} />

经典示例

```python showLineNumbers
import re

# findall
target = 'life is short, i learn python.'
result = re.findall('python', target)
result1 = re.findall('java', target)
# findall是re库的一个重要方法，第一个参数是匹配规则，第二个参数是要匹配的目标字符串，还有第三个参数，我们之后讲，findall返回的结果是一个列表。
# result这行代码的意思是从target中匹配'python',如果匹配到就返回，没有匹配到就返回空列表。
print(result)# 得到的结果是['python']
print(result1)# 得到的结果是[]


# 元字符
target = 'abc acc aec agc adc aic'
result = re.findall('a[de]c', target)
# 这一行中的[de]表示这个位置上的字符是d或者是e都可以匹配出来
print(result)# 得到的结果是['aec', 'adc']

result = re.findall('a[b‐z]c', target)
# 这一行中的[b‐z]表示这个位置上的字符在b‐z范围内都可以匹配出来
print(result)# 得到的结果是['abc', 'acc', 'aec', 'agc', 'adc', 'aic']

result = re.findall('a[^c‐z]c', target)
# 这一行中的[^c‐z]表示这个位置上的字符不在c‐z范围内都可以匹配出来，注意是不在
print(result)# 得到的结果是['abc']


# 示例
text = '我住在3号楼666,我的电话号码是17606000003你后面有事给我打电话，打不通就打17327567890。实在不行就打固定电话010-7788'
result = re.findall('\d{3}[\d-]\d*',text)
# \d{3}代表至少3个数字起匹配（区号和电话号码都满足）
# [\d-]代表后面跟着的可以是数字（电话号码），也可以是-
# \d*代表后面的数字我都要
print(result)#结果是['17606000003', '17327567890', '010-7788']


# 分组
line = "Cats are smarter than dogs"
matchObj = re.match( r'(.*) are (.*?) .*', line, re.M|re.I)
#re.M表示多行匹配，影响 ^ 和 $
#re.I 使匹配对大小写不敏感
if matchObj:
   print ("matchObj.group() : ", matchObj.group())#返回所有组
   print ("matchObj.group(1) : ", matchObj.group(1)) # 返回组1【注意不是从0开始】
   print ("matchObj.group(2) : ", matchObj.groups())# 返回所有组的元组形式
else:
   print ("No match!!")


# 替换与检索sub
phone = "2004-959-559 # 这是一个国外电话号码"
# 删除字符串中的 Python注释
num = re.sub(r'#.*$', "", phone)
print ("电话号码是: ", num)
# 删除非数字(-)的字符串
num = re.sub(r'\D', "", phone)
print ("电话号码是 : ", num)

# 将匹配的数字乘以 2
def double(matched):
    value = int(matched.group('value'))
    return str(value * 2)
s = 'A23G4HFD567'
print(re.sub('(?P<value>\d+)', double, s))


#贪婪与非贪婪
content = '发布于2018/12/23'
result = re.findall('.*?(\d.*\d)', content)
"""
这里的?表示的就是非贪婪模式，第一个.*会尽可能少地去匹配内容
因为后面跟的是\d，所以碰见第一个数字就终止了。
"""
print(result) # ['2018/12/23']

result = re.findall('.*(\d.*\d)', content)
"""
这里的第一个.*后面没有添加问号，表示的就是贪婪模式，第一个.*会尽可能多地去匹配内容
后面跟的是\d，碰见第一个数字并不一定会终止，当它匹配到2018的2的时候，发现剩#下的内容依然满足(\d.*\d)，所以会一直匹配下去
直到匹配到12后面的/的时候，发现剩下的23依然满足(\d.*\d)，但是如果再匹配下去，匹配到23的2的话，剩下的3就不满足(\d.*\d)了
所以第一个.*就会停止匹配，(\d.*\d)最终匹配到的结果就只剩下23了。
"""
print(result) # ['23']

result = re.findall('.*?(\d.*?\d)', content)
"""
这里的第一个.*?表示非贪婪模式(非贪婪模式就是尽可能少地去匹配字符)，匹配到2018前面的'于'之后就停止了
括号里的.*?也是表示非贪婪模式，括号里的内容从2018的2开始匹配，因为后面一个数字是0，那么也就满足了(\d.*?\d)
所以就直接返回结果了，同样的，接下来的18也是这样，一直匹配到23才结束
"""
print(result) # ['20', '18', '12', '23']
```
