---
sidebar_position: 2
title: 元组
---

## 元组

与列表相似，元组 tuple 也是个有序序列，用`,`生成，有些教程中会额外使用`()`来包裹数据，让数据看起来更清晰。

```python showLineNumbers
# 创建空元组
a = ()
# 等价于
a = tuple()
print(type(a)) # <class 'tuple'>

# 将其他序列转化成元组
a = [1, 2, 3]
b = tuple(a)
print(b)  # (1, 2, 3)

# 创建多个元素的元组
a = 10, 11, 12, 13, 14
# 通常也可以写作 a = (10, 11, 12, 13, 14)
print(a)

# 创建单个元素的元组
b = 10,
# 或者是 b = (10,)
print(b) # (10,)
print(type(b))  # <class 'tuple'>


# 可以索引，切片：
c = a[0]
print(c)

c = a[1:3]
print(c)  # (11, 12)

# 不可变对象的优化
# 原则上来说下面的代码执行结果应该都是False，但是Python对不可变对象进行了驻留优化，所以结果都是True。
import copy
a= (1,2,3)
b = a[:]
c = tuple(a)
d = copy.deepcopy(a) # 深拷贝不总是创建一个新的对象
print(a is b) # True
print(a is c) # True
print(a is d) # True

# 可变对象的结果是符合预期的
import copy
a= [1,2,3]
b = a[:]
c = list(a)
d = copy.deepcopy(a)
print(a is b) # False
print(a is c) # False
print(a is d) # False
```

大部分教程中指出元组是不可变的，但是严格来说，元组只是每个元素的id不能被改变。

前面我们学习过：数据一旦被创建，修改数据后，其内存地址不会改变。因为如果内存地址发生了改变，变量的指向就会异常。

下面展示了元组每个元素的id不会改变，但是元素的值可以被改变。

```python showLineNumbers
a = [1,2,3]
print(id(a)) # 2060220698944

a.append(4)
print(a) # [1, 2, 3, 4]
print(id(a)) # 2060220698944

tuples = (1, 2, [1,2,3])
tuples[2][0].append(4)
print(tuples)  # (1, 2, [1,2,3,4])
```
