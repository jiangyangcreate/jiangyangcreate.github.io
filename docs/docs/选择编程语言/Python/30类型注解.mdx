---
sidebar_position: 30
title: 类型注解
---
## 类型注解

类型注解是Python 3.5+ 引入的特性，用于在代码中添加类型信息。

语法为 `variable: type`,可以当作一种文档注释，用于描述变量、函数参数和返回值的类型。同时和注释一样，不会影响运行时行为，即便输入的参数类型不匹配，也不会报错。

当然，类型注解也可以用于类、函数、方法、模块等。

```python showLineNumbers
# 基本类型注解
name: str = "Alice"
age: int = 30

# 函数参数和返回值注解
def greet(name: str, age: int = 25) -> str:  # 带默认值的参数
    return f"{name} is {age} years old"

greet("Alice", '30') # 即便输入的参数类型不匹配，也不会报错。
```

## typing 模块

`typing` 模块提供高级类型支持：

```python
from typing import List, Dict, Tuple, Optional, Union

# 容器类型
names: List[str] = ["Alice", "Bob"]
person: Dict[str, Union[str, int]] = {"name": "Alice", "age": 30}

# 可选类型
def get_age(name: str) -> Optional[int]:
    if name == "Alice":
        return 30
    return None

# 类型别名
UserId = int
user_id: UserId = 1001
```

## 高级类型注解

Python 3.10+ 支持更简洁的语法：

```python
# 联合类型 (替代 Union)
def process(data: str | int) -> None:
    pass

# 可选类型 (替代 Optional)
def find_user(id: int) -> str | None:
    pass
```

## Callable 可调用类型

用于标注函数参数或返回值：

```python
from typing import Callable

def apply_function(func: Callable[[int, int], int], x: int, y: int) -> int:
    return func(x, y)

# 使用示例
result = apply_function(lambda a, b: a + b, 5, 3)

# 无参数的可调用对象
def run_task(task: Callable[[], None]) -> None:
    task()
```

## Protocol 协议类型

定义结构化类型，实现鸭子类型：

```python
from typing import Protocol

class Drawable(Protocol):
    def draw(self) -> None: ...

class Circle:
    def draw(self) -> None:
        print("Drawing circle")

def render(obj: Drawable) -> None:
    obj.draw()

# Circle 没有继承 Drawable，但符合协议
render(Circle())  # 正确
```

## 泛型 (Generic)

创建可复用的类型安全容器：

```python
from typing import TypeVar, Generic, List

T = TypeVar('T')

class Stack(Generic[T]):
    def __init__(self) -> None:
        self._items: List[T] = []
    
    def push(self, item: T) -> None:
        self._items.append(item)
    
    def pop(self) -> T:
        return self._items.pop()

# 使用
int_stack: Stack[int] = Stack()
int_stack.push(42)
```

## Literal 字面量类型

限制值只能是特定的字面量：

```python
from typing import Literal

def set_mode(mode: Literal["read", "write", "append"]) -> None:
    print(f"Mode set to: {mode}")

set_mode("read")    # 正确
set_mode("delete")  # 类型检查器会报错

# 多种类型的字面量
def process_flag(flag: Literal[True, False, 0, 1]) -> None:
    pass
```

## Final 和 ClassVar

控制变量的可变性和作用域：

```python
from typing import Final, ClassVar

class Config:
    # 常量，不可修改
    MAX_SIZE: Final[int] = 100
    # 类变量，所有实例共享
    instance_count: ClassVar[int] = 0
    
    def __init__(self) -> None:
        Config.instance_count += 1
        # self.MAX_SIZE = 200  # 类型检查器会报错

# 模块级常量
API_VERSION: Final = "v1.0"
```

## 类型检查工具

### mypy 使用技巧

```python
# 忽略某行的类型检查
def legacy_function():  # type: ignore
    return "no type hints"

# 忽略特定错误类型
x: int = "hello"  # type: ignore[assignment]

# 条件类型检查
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from some_module import ExpensiveClass
```

### 运行时类型检查

```python
from typing import get_type_hints
import inspect

def example(x: int, y: str = "default") -> str:
    return f"{x}: {y}"

# 获取函数的类型提示
hints = get_type_hints(example)
print(hints)  # {'x': <class 'int'>, 'y': <class 'str'>, 'return': <class 'str'>}

# 检查函数签名
sig = inspect.signature(example)
for param in sig.parameters.values():
    print(f"{param.name}: {param.annotation}")
```

## type 和 object 的关系

Python 中所有类都是 `type` 的实例，而 `type` 本身也是类：
- `object` 是所有类的基类
- `type` 是 `object` 的子类，也是自身的元类

```python
# type 和 object 的关系验证
print(issubclass(type, object))  # True
print(isinstance(object, type))  # True
print(isinstance(type, type))    # True
```

关键点：
1. `type` 是创建类的类 (元类)
2. `object` 是所有类的基类
3. 类既是 `type` 的实例，又是 `object` 的子类

## 最佳实践

### 1. 渐进式类型注解
```python
# 从简单开始
def add(a, b):
    return a + b

# 逐步添加类型
def add(a: int, b: int) -> int:
    return a + b
```

### 2. 使用类型别名提高可读性
```python
from typing import Dict, List

# 复杂类型的别名
UserData = Dict[str, Union[str, int, List[str]]]
UserDatabase = Dict[int, UserData]

def get_user(db: UserDatabase, user_id: int) -> UserData:
    return db[user_id]
```

### 3. 合理使用 Any
```python
from typing import Any

# 明确表示任意类型
def process_json(data: Any) -> Dict[str, Any]:
    # 处理未知结构的 JSON 数据
    return {"processed": data}
```
