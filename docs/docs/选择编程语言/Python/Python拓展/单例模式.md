---
sidebar_position: 1
title: 单例模式
description: 深入理解Python中的单例设计模式，包括多种实现方式和应用场景
keywords: [Python, 设计模式, 单例模式, __new__, 装饰器, 元类]
---

## 单例模式

单例模式目的：让类创建的对象，在系统中只有 **唯一的一个实例**

特点：每一次执行 `类名()` 返回的对象，内存地址是相同的


### 方法一：使用 `__new__` 方法

#### 基本实现

```python showLineNumbers title="单例模式基础实现"
class MusicPlayer(object):
    # 记录第一个被创建对象的引用
    instance = None
    
    def __new__(cls, *args, **kwargs):
        # 1. 判断类属性是否为空对象
        if cls.instance is None:
            # 调用父类方法为第一个对象分配空间
            cls.instance = super().__new__(cls)
        
        # 2. 返回类属性保存的对象引用
        return cls.instance

# 测试单例效果
player1 = MusicPlayer()
player2 = MusicPlayer()

print(f"player1: {player1}")
print(f"player2: {player2}")
print(f"是否为同一对象: {player1 is player2}")  # True
```

#### 优化：只初始化一次


上述实现中，虽然返回的是同一个对象，但 `__init__` 方法会被多次调用


```python title="确保初始化只执行一次" {16-23}
class MusicPlayer(object):
    # 记录第一个被创建对象的引用
    instance = None
    # 记录初始化执行状态
    init_flag = False

    def __new__(cls, *args, **kwargs):
        if cls.instance is None:
            cls.instance = super().__new__(cls)
        return cls.instance

    def __init__(self):
        # 1. 判断是否执行过初始化动作
        if MusicPlayer.init_flag:
            return
        
        # 2. 如果没有执行过就执行初始化动作
        print("播放器初始化")
        
        # 3. 修改初始化状态
        MusicPlayer.init_flag = True


# 测试
player1 = MusicPlayer()  # 输出: 播放器初始化
player2 = MusicPlayer()  # 不会再次初始化
```

### 方法二：使用装饰器 

```python title="装饰器实现单例"
def singleton(cls):
    """单例装饰器"""
    instances = {}
    
    def get_instance(*args, **kwargs):
        if cls not in instances:
            instances[cls] = cls(*args, **kwargs)
        return instances[cls]
    
    return get_instance

@singleton
class MySingleton:
    def __init__(self, param):
        self.param = param
        print(f"初始化参数: {param}")

# 使用示例
if __name__ == '__main__':
    a = MySingleton(10)  # 输出: 初始化参数: 10
    b = MySingleton(20)  # 不会再次初始化
    
    print(f"a.param: {a.param}")  # 10
    print(f"b.param: {b.param}")  # 10
    print(f"是否为同一对象: {a is b}")  # True
```

:::tip 装饰器优势
- 代码简洁优雅
- 可重用性强
- 不需要修改原类的内部结构
:::

### 方法三：使用类方法 

```python title="类方法实现单例"
class Singleton(object):
    def __init__(self, name):
        self.name = name

    @classmethod
    def instance(cls, *args, **kwargs):
        if not hasattr(cls, "_instance"):
            cls._instance = cls(*args, **kwargs)
        return cls._instance

# 使用示例
single_1 = Singleton.instance('第1次创建')
single_2 = Singleton.instance('第2次创建')

print(f"single_1.name: {single_1.name}")  # 第1次创建
print(f"single_2.name: {single_2.name}")  # 第1次创建
print(f"是否为同一对象: {single_1 is single_2}")  # True
```

#### 线程安全版本

:::warning 多线程问题
上述实现在多线程环境下不安全，需要加锁保护
:::

```python title="线程安全的类方法单例"
from threading import RLock

class Singleton(object):
    _lock = RLock()  # 可重入锁

    def __init__(self, name):
        self.name = name

    @classmethod
    def instance(cls, *args, **kwargs):
        # 使用锁确保线程安全
        with cls._lock:
            if not hasattr(cls, "_instance"):
                cls._instance = cls(*args, **kwargs)
        return cls._instance
```

### 方法四：使用元类

```python title="元类实现单例"
class SingletonType(type):
    def __call__(cls, *args, **kwargs):
        # 创建 cls 的对象时调用
        if not hasattr(cls, "_instance"):
            # 创建 cls 的对象
            cls._instance = super(SingletonType, cls).__call__(*args, **kwargs)
        return cls._instance

class Singleton(metaclass=SingletonType):
    def __init__(self, name):
        self.name = name

# 使用示例
single_1 = Singleton('第1次创建')
single_2 = Singleton('第2次创建')

print(f"single_1.name: {single_1.name}")  # 第1次创建
print(f"single_2.name: {single_2.name}")  # 第1次创建
print(f"是否为同一对象: {single_1 is single_2}")  # True
```

:::info 元类原理
- `Singleton` 是元类 `SingletonType` 的实例
- `Singleton('参数')` 实际上是调用元类的 `__call__` 方法
- 使用 `super()` 避免递归调用
:::

### 方法五：使用模块

:::tip 官方推荐
这是 Python 官方推荐的单例实现方式，简单且天然线程安全
:::

```python title="my_singleton.py - 模块单例"
class Singleton:
    def __init__(self, name):
        self.name = name

    def do_something(self):
        print(f"{self.name} 正在工作...")

# 创建单例实例
singleton = Singleton('模块单例')
```

```python title="使用模块单例"
# file1.py
from my_singleton import singleton
print(f"file1 中的 singleton: {singleton}")

# file2.py  
from my_singleton import singleton
print(f"file2 中的 singleton: {singleton}")

# 测试文件
import file1
import file2

print(f"是否为同一对象: {file1.singleton is file2.singleton}")  # True
```

