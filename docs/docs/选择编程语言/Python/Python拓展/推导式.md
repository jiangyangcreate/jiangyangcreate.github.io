
推导式（Comprehensions）是 Python 中一种简洁、高效的创建数据结构的语法糖。它能够用一行代码完成原本需要多行循环才能实现的功能，不仅代码更加简洁，执行效率也更高。

## 列表推导式

### 基本语法

列表推导式的基本语法结构如下：

```python
[expression for item in iterable]
```

这相当于：

```python
result = []
for item in iterable:
    result.append(expression)
```

### 基础示例

```python
# 创建平方数列表
squares = [x**2 for x in range(10)]
print(squares)  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 字符串转大写
words = ['hello', 'world', 'python']
upper_words = [word.upper() for word in words]
print(upper_words)  # ['HELLO', 'WORLD', 'PYTHON']

# 提取数字的个位数
numbers = [123, 456, 789]
last_digits = [num % 10 for num in numbers]
print(last_digits)  # [3, 6, 9]
```

### 带条件的列表推导式

#### 条件过滤（if 语句）

```python
# 基本语法
[expression for item in iterable if condition]

# 示例：筛选偶数
numbers = range(20)
even_numbers = [x for x in numbers if x % 2 == 0]
print(even_numbers)  # [0, 2, 4, 6, 8, 10, 12, 14, 16, 18]

# 筛选正数并求平方
numbers = [-3, -2, -1, 0, 1, 2, 3]
positive_squares = [x**2 for x in numbers if x > 0]
print(positive_squares)  # [1, 4, 9]

# 筛选特定长度的字符串
words = ['cat', 'dog', 'elephant', 'bird', 'python']
long_words = [word for word in words if len(word) > 4]
print(long_words)  # ['elephant', 'python']
```

#### 条件表达式（三元运算符）

```python
# 语法：expression1 if condition else expression2
[expression1 if condition else expression2 for item in iterable]

# 示例：将负数转为0，正数保持不变
numbers = [-3, -1, 0, 2, 5]
processed = [x if x >= 0 else 0 for x in numbers]
print(processed)  # [0, 0, 0, 2, 5]

# 根据条件设置不同的值
scores = [85, 92, 78, 96, 73]
grades = ['A' if score >= 90 else 'B' if score >= 80 else 'C' for score in scores]
print(grades)  # ['B', 'A', 'C', 'A', 'C']
```

### 嵌套循环

```python
# 基本语法
[expression for item1 in iterable1 for item2 in iterable2]

# 示例：生成坐标点
coordinates = [(x, y) for x in range(3) for y in range(3)]
print(coordinates)
# [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]

# 矩阵展平
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [num for row in matrix for num in row]
print(flattened)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]

# 带条件的嵌套循环
result = [(x, y) for x in range(5) for y in range(5) if x + y == 4]
print(result)  # [(0, 4), (1, 3), (2, 2), (3, 1), (4, 0)]
```

### 复杂示例

```python
# 处理字符串列表
sentences = ['Hello World', 'Python Programming', 'Data Science']
word_lengths = [[len(word) for word in sentence.split()] for sentence in sentences]
print(word_lengths)  # [[5, 5], [6, 11], [4, 7]]

# 过滤和转换文件名
filenames = ['data.txt', 'image.jpg', 'script.py', 'document.pdf', 'code.py']
python_files = [filename.upper() for filename in filenames if filename.endswith('.py')]
print(python_files)  # ['SCRIPT.PY', 'CODE.PY']

# 处理嵌套数据结构
students = [
    {'name': 'Alice', 'scores': [85, 90, 88]},
    {'name': 'Bob', 'scores': [78, 85, 92]},
    {'name': 'Charlie', 'scores': [92, 88, 95]}
]
averages = [{'name': student['name'], 'average': sum(student['scores'])/len(student['scores'])} 
           for student in students]
print(averages)
# [{'name': 'Alice', 'average': 87.67}, {'name': 'Bob', 'average': 85.0}, {'name': 'Charlie', 'average': 91.67}]
```

## 字典推导式

### 基本语法

```python
{key_expression: value_expression for item in iterable}
```

### 基础示例

```python
# 创建平方数字典
squares_dict = {x: x**2 for x in range(5)}
print(squares_dict)  # {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# 字符串长度字典
words = ['apple', 'banana', 'cherry']
word_lengths = {word: len(word) for word in words}
print(word_lengths)  # {'apple': 5, 'banana': 6, 'cherry': 6}

# 反转字典
original = {'a': 1, 'b': 2, 'c': 3}
reversed_dict = {v: k for k, v in original.items()}
print(reversed_dict)  # {1: 'a', 2: 'b', 3: 'c'}
```

### 带条件的字典推导式

```python
# 筛选偶数键值对
numbers = range(10)
even_squares = {x: x**2 for x in numbers if x % 2 == 0}
print(even_squares)  # {0: 0, 2: 4, 4: 16, 6: 36, 8: 64}

# 过滤字典
scores = {'Alice': 85, 'Bob': 92, 'Charlie': 78, 'Diana': 96}
high_scores = {name: score for name, score in scores.items() if score >= 90}
print(high_scores)  # {'Bob': 92, 'Diana': 96}

# 条件值设置
numbers = range(-3, 4)
abs_dict = {x: abs(x) if x < 0 else x for x in numbers}
print(abs_dict)  # {-3: 3, -2: 2, -1: 1, 0: 0, 1: 1, 2: 2, 3: 3}
```

### 复杂示例

```python
# 统计字符频率
text = "hello world"
char_count = {char: text.count(char) for char in set(text) if char != ' '}
print(char_count)  # {'e': 1, 'h': 1, 'l': 3, 'o': 2, 'r': 1, 'd': 1, 'w': 1}

# 分组数据
students = ['Alice', 'Bob', 'Charlie', 'Diana', 'Eve']
grouped = {len(name): [n for n in students if len(n) == len(name)] for name in students}
# 去重
grouped = {length: list(set(names)) for length, names in grouped.items()}
print(grouped)  # {5: ['Alice', 'Diana'], 3: ['Bob', 'Eve'], 7: ['Charlie']}

# 嵌套字典处理
data = [
    {'name': 'Alice', 'age': 25, 'city': 'New York'},
    {'name': 'Bob', 'age': 30, 'city': 'London'},
    {'name': 'Charlie', 'age': 35, 'city': 'Tokyo'}
]
name_to_info = {person['name']: {k: v for k, v in person.items() if k != 'name'} 
                for person in data}
print(name_to_info)
# {'Alice': {'age': 25, 'city': 'New York'}, 'Bob': {'age': 30, 'city': 'London'}, 'Charlie': {'age': 35, 'city': 'Tokyo'}}
```

## 集合推导式

### 基本语法

```python
{expression for item in iterable}
```

### 示例

```python
# 创建平方数集合
squares_set = {x**2 for x in range(10)}
print(squares_set)  # {0, 1, 4, 9, 16, 25, 36, 49, 64, 81}

# 提取唯一字符
text = "hello world"
unique_chars = {char.upper() for char in text if char != ' '}
print(unique_chars)  # {'H', 'E', 'L', 'O', 'W', 'R', 'D'}

# 过滤重复值
numbers = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4]
unique_evens = {x for x in numbers if x % 2 == 0}
print(unique_evens)  # {2, 4}
```

## 生成器表达式

### 基本语法

```python
(expression for item in iterable)
```

生成器表达式与列表推导式类似，但使用圆括号，返回生成器对象而不是列表，具有内存效率优势。

### 示例

```python
# 创建生成器
squares_gen = (x**2 for x in range(10))
print(type(squares_gen))  # <class 'generator'>

# 迭代生成器
for square in squares_gen:
    print(square, end=' ')  # 0 1 4 9 16 25 36 49 64 81

# 内存效率对比
import sys

# 列表推导式
list_comp = [x**2 for x in range(1000)]
print(f"列表大小: {sys.getsizeof(list_comp)} bytes")

# 生成器表达式
gen_exp = (x**2 for x in range(1000))
print(f"生成器大小: {sys.getsizeof(gen_exp)} bytes")

# 转换为其他数据结构
numbers = (x for x in range(5))
numbers_list = list(numbers)  # [0, 1, 2, 3, 4]
```

## 三元表达式（条件表达式）

### 基本语法

```python
expression1 if condition else expression2
```

三元表达式是一种简洁的条件赋值方式，相当于简化版的 if-else 语句。

### 基础示例

```python
# 基本用法
age = 20
status = "成年人" if age >= 18 else "未成年人"
print(status)  # 成年人

# 数值处理
x = -5
abs_x = x if x >= 0 else -x
print(abs_x)  # 5

# 字符串处理
name = ""
display_name = name if name else "匿名用户"
print(display_name)  # 匿名用户
```

### 嵌套三元表达式

```python
# 多重条件
score = 85
grade = "A" if score >= 90 else "B" if score >= 80 else "C" if score >= 70 else "D"
print(grade)  # B

# 更复杂的嵌套
temperature = 25
weather = "热" if temperature > 30 else "温暖" if temperature > 20 else "凉爽" if temperature > 10 else "寒冷"
print(weather)  # 温暖
```

### 在函数中的应用

```python
def get_max(a, b):
    return a if a > b else b

def safe_divide(a, b):
    return a / b if b != 0 else 0

def format_number(num):
    return f"{num:,.2f}" if isinstance(num, (int, float)) else "无效数字"

print(get_max(10, 20))  # 20
print(safe_divide(10, 0))  # 0
print(format_number(1234.567))  # 1,234.57
```

## 常见错误与解决方案

### 1. 变量作用域问题

```python
# 错误示例
functions = []
for i in range(5):
    functions.append(lambda: i)  # 所有lambda都引用同一个i
# 或 functions = [lambda : x for i in range(5)]

# 问题：所有函数都返回4
print([f() for f in functions])  # [4, 4, 4, 4, 4]

# 方法1：使用默认参数捕获值(简单，但是不推荐)
fs1 = [lambda i=i: i for i in range(3)]
print("方法1:", [f() for f in fs1])

# 方法2：使用闭包函数(推荐)
def make_function(x):
    return lambda: x
fs2 = [make_function(i) for i in range(3)]
print("方法2:", [f() for f in fs2])

# 方法3：使用functools.partial
from functools import partial
fs3 = [partial(lambda x: x, i) for i in range(3)]
print("方法3:", [f() for f in fs3])
```

### 2. 过度嵌套

```python
# 不好的做法：过度嵌套
result = [[[y**2 for y in x if y > 0] for x in row if len(x) > 2] for row in matrix if row]

# 好的做法：分步处理
filtered_matrix = [row for row in matrix if row]
filtered_rows = [x for row in filtered_matrix for x in row if len(x) > 2]
result = [[y**2 for y in x if y > 0] for x in filtered_rows]
```

### 3. 内存使用不当

```python
# 大数据集时避免使用列表推导式
# 不好：一次性创建大列表
big_list = [expensive_operation(x) for x in range(1000000)]

# 好：使用生成器表达式
big_generator = (expensive_operation(x) for x in range(1000000))
for item in big_generator:
    process(item)  # 逐个处理，节省内存
```
