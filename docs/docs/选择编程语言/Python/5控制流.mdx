---
sidebar_position: 5
title: 控制流
---
:::info
代码布局不仅影响可读性，更体现了对代码质量的态度。一致的缩进、适当的空行、合理的行长度，这些细节共同构成了优雅的Python代码。

- 使用4个空格进行缩进
- 每行不超过79个字符  
- 用空行分隔顶级函数和类定义

[PEP 8 – Python代码风格指南](https://peps.python.org/pep-0008/)
:::
## 条件判断

条件判断是编程中非常基础且重要的概念，它允许我们根据不同的条件执行不同的代码块。

### if, elif, else

```python showLineNumbers
if condition:
    # 当条件为真时执行的代码块
elif condition:
    # 当条件为假时执行的代码块
else:
    # 当条件都不满足时执行的代码块

a = 62
print("exam score check:")
if a >= 60:
    print("student pass")
elif a == 0:
    print("student 0: not pass")
else:
    print("student not pass")
```

一个例子

```python showLineNumbers
year = 1900
if year % 400 == 0:
    print("This is a leap year!")
# 两个条件都满足才执行
elif year % 4 == 0 and year % 100 != 0:
    print("This is a leap year!")
else:
    print("This is not a leap year.")
# This is not a leap year.

my_list = [1, 2]
# 判断一个列表是否为空。
if len(my_list) > 0:
    print("the first element is: ", my_list[0])
else:
    print("no element.")

```
:::info
三元表达式是一种简洁的条件赋值方式，相当于简化版的 if-else 语句。一行语句实现一个条件赋值。非常Pythonic。

```python showLineNumbers
expression1 if condition else expression2
```
其中`expression1`和`expression2`可以是任意表达式，`condition`是任意条件表达式。

当`condition`为True时，返回`expression1`，否则返回`expression2`。

下面通过括号（可省）将同个表达式的部分标注了出来，更加可读。

```python showLineNumbers
x = -1
y = ("A") if (x > 0) else ("B")
print(y) # B
y = (x + 1) if (x > 0) else (x - 1)
print(y) # -2
```
:::

### pass 语句

`pass` 是一个空操作语句，它什么都不做。当语法上需要一个语句(判断、循环、函数、类等语句中)，但程序不需要任何操作时，可以使用 `pass`。

完全是为了满足Python的语法要求，在开发时临时填充代码结构，或者在某些控制流中明确表示"不执行任何操作"。

```python showLineNumbers
# 条件语句中的占位符
if 0 == 0:
    pass  # 暂时不处理这种情况

# 用作函数占位符
def my_function():
    pass  # 稍后实现
```

### assert 语句

`assert` 语句用于调试时的断言检查。后面可以跟一个条件表达式和一个可选的错误信息。

它会测试条件表达式，如果条件为 `False`，则抛出 `AssertionError` 异常，并显示可选的错误信息。

```python showLineNumbers
x = 1
y = 0
assert y != 0, "0 不能作为分母"
print(x / y)
'''
输出：
AssertionError: 0 不能作为分母
'''
```

### match, case 语句

:::info

即便你从未学习过match, case 语句，你也可以轻松的看懂match, case 语句的用法。它是最具有可读性的条件判断语句。

[PEP 636 – 结构匹配：教程](https://peps.python.org/pep-0636/)
[PEP 635 - 结构匹配：动机和基本原理](https://peps.python.org/pep-0635/)
[PEP 634 – 结构匹配：规范](https://peps.python.org/pep-0634/)
:::

如果需要对一个表达式进行多个条件的判断，可以使用 match, case 语句。

match case 匹配语法更简洁、匹配时自动绑定变量、支持模式组合、支持通配符。尤其对 JSON 数据结构解析非常友好。

当其满足多个条件时，会从上到下依次判断，直到匹配到第一个条件为止。



## 循环

循环是编程中另一个重要的概念，它允许我们重复执行一段代码。


### for 循环

```python showLineNumbers
# for 循环
total = 0
for i in range(100000):
    total += i
print(total)  # 4999950000
```

### while 循环

```python showLineNumbers
while <condition>:
     <statesments>

```

Python 会循环执行**statesments**，直到**condition**不满足为止。

```python showLineNumbers
i = 0
total = 0
while i <= 100:
    total += i
    i += 1
print(total)  # 5050
```

举个例子，通过 while 遍历集合：

```python showLineNumbers
# 空容器会被当成False，因此可以用while循环读取容器的所有元素
plays = set(['Hamlet', 'Mac', 'King'])
while plays:
    play = plays.pop()
    print('Perform', play)
```

### continue 语句

遇到 continue 的时候，程序会返回到循环的最开始重新执行。

```python showLineNumbers
values = [7, 6, 4, 7, 19, 2, 1]
for i in values:
    if i % 2 != 0:
        # 忽略奇数
        continue
    print(i)
# 6
# 4
# 2
```

### break 语句

遇到 break 的时候，程序会跳出循环，不管循环条件是不是满足

```python showLineNumbers
command_list = ['start',
                '1',
                '2',
                '3',
                '4',
                'stop',
                'restart',
                '5',
                '6']
while command_list:
    command = command_list.pop(0)
    if command == 'stop':
        break
    print(command)
# start
# 1
# 2
# 3
# 4

```


## 异常处理

### try & except &finally

`try`不能单独执行，可以分为以下几种情况：

- `try`  + 大于等于1个`except` 
- `try`  + 大于等于1个`except`  + `finally` 
- `try`  + `finally` 

<Highlight>在 标准 的 `try...except` 结构中，通常只会触发一个 `except` 块。</Highlight>

```python showLineNumbers
# 捕捉不同的错误类型，尝试在下面输入框输入：-1，1，2，q
import math

while True:
    try:
        # 尝试执行代码块，如果发生异常，则跳转到对应的except块
        text = input('>')
        if text[0] == 'q':
            break
        x = float(text)
        y = 1 / math.log10(x)
        print("1/log10({0}) = {1}".format(x, y))
    # 如果发生ValueError异常，则跳转到对应的except块内
    except ValueError:
        print("value must bigger than 0")
    # 如果发生ZeroDivisionError异常，则跳转到对应的except块内，异常可以被捕获为别名，便于使用（例如记录到日志等）
    except ZeroDivisionError as e:
        print("the value must not be 1", e)

```

不管 `try` 块有没有异常， `finally` 块的内容总是会被执行，而且会在抛出异常前执行，因此可以用来作为安全保证，比如文件操作时，常在 `finally` 关闭文件。

有时候你希望不捕获异常，让异常正常向上传播，但确保清理代码一定执行。可以结合 `try` 和 `finally` 来实现。

```python showLineNumbers
def process_file(filename):
    f = open(filename, 'r')
    try:
        # 不管这里出现什么异常，都要关闭文件
        data = f.read()
        result = complex_processing(data)  # 可能抛出各种异常
        return result
    finally:
        f.close()  # 确保文件被关闭
        print("文件已关闭")
    # 如果出现异常，会在finally执行后继续向上抛出
```

:::info
由于 `finally` 的特性，目前3.14版本中`finally`块中`return`、`break`、`continue`语句都算语法错误。

下面是一些危险的例子。

```python showLineNumbers
# 返回值被意外覆盖
# 无论计算成功还是失败，最终都会返回-1
def calculate_score(user_id):
    try:
        score = expensive_calculation(user_id)
        return score  # 比如返回95分
    except Exception as e:
        logger.error(f"计算用户{user_id}分数时出错: {e}")
        return 0  # 出错时返回0分
    finally:
        return -1  # 🚨 危险！总是返回-1，覆盖前面的返回值

# 异常被意外吞噬
# 这个示例中，内存错误没有被抛出，而是被吞噬了！
def dangerous_file_operation():
    try:
        # 模拟一些可能出错的操作
        raise ValueError("数据处理错误")
    except ValueError as e:
        print(f"数据处理错误: {e}")
        # 想要将异常写入数据库，但是数据库报内存错误
        raise MemoryError("内存错误")
    finally:
        print("finally")
        return "default_value" 
dangerous_file_operation()
```
:::
### except* 与 ExceptionGroup

当需要引发多个不相关的异常时，<Highlight>`ExceptionGroup`</Highlight>被使用。

`ExceptionGroup`是异常层次结构的一部分，是`Exception`异常的子类，因此可以像所有其他异常一样使用 `except` 进行处理。

```python showLineNumbers
try:
    raise ExceptionGroup("test", [ValueError("test1"),ZeroDivisionError("test2")])
except ExceptionGroup :
    print('ExceptionGroup') # 处理ValueError异常
"""
ExceptionGroup
"""
```

此外，它们被 `except*` 识别，该识别器根据所包含异常的类型匹配它们的子组。

:::tip
注意：

`except*` 和 `except` 不能同时使用。

与<Highlight>在 标准 的 `try...except` 结构中，通常只会触发一个 `except` 块。</Highlight>不同，使用`except*`时，每个被`except*`捕获的1个或多个异常都会被抛出为一个新的异常组(包含被捕获的一个或多个异常)。直到所有异常都被抛出。

如果except* 结束还有异常，则这些剩下异常会继续被抛出为一个异常组。
:::

```python showLineNumbers
try:
    raise ExceptionGroup("test", [ValueError("test1"),ZeroDivisionError("test2"),MemoryError("test3"),SyntaxError("test4")])
except* ValueError as e:
    # 这里的 e 是一个新的 ExceptionGroup
    print('ValueError:',e) # 处理ValueError异常
except* ZeroDivisionError as e:
    # 这里的 e 是一个新的 ExceptionGroup
    print('ZeroDivisionError:', e)
except* Exception as e:
    print('Exception:',e) # 处理Exception异常
"""
ValueError: test (1 sub-exception)
ZeroDivisionError: test (1 sub-exception)
Exception: test (2 sub-exceptions)
"""
```

捕获到异常组之后，可以对异常组做进一步拆分处理。

```python showLineNumbers
try:
    raise ExceptionGroup("test", [ValueError("test1"),ZeroDivisionError("test2"),MemoryError("test3"),SyntaxError("test4")])
except* ValueError as e:
    # 异常组.message 是该异常组的描述，即"test"
    print(e.message) # test
    # 异常组.exceptions 是该异常组的子异常元组
    for exc in e.exceptions:
        print(exc) # test1
except* ZeroDivisionError as e:
    # 异常组.subgroup(condition)返回一个仅包含当前组中与 condition 匹配的异常的异常组，如果结果为空，则返回 None 。
    print(e.subgroup(EncodingWarning)) # None
    print(e.subgroup(ZeroDivisionError)) # test (1 sub-exception)
except* Exception as e:
    # 异常组.split(condition)类似于 subgroup() ，但返回 (match, rest) 对，其中 match 是匹配部分， rest 是剩余的非匹配部分。
    print(e.split(MemoryError)) 
    # (ExceptionGroup('test', [MemoryError('test3')]), ExceptionGroup('test', [SyntaxError('test4')]))

    """
    异常组.derive(excs)返回一个与异常组具有相同 message 的异常组，但将异常包装在 excs 中。
    此方法一般不直接调用，而是由之前的 subgroup() 和 split() 使用

    new_error_Group = e.derive([EncodingWarning("test5"),SyntaxError("test6")])
    几乎等价于，
    new_error_Group = ExceptionGroup(e.message, [EncodingWarning("test5"),SyntaxError("test6")])
    """

"""
test
test1
None
test (1 sub-exception)
(ExceptionGroup('test', [MemoryError('test3')]), ExceptionGroup('test', [SyntaxError('test4')]))
"""
```

### raise 语句

:::info 

frame对except的影响

以下代码在 Python3.14.0rc0 中依然存在。

```python showLineNumbers
e = 1
try:
    0/0 # 此处会抛出错误，因为0不能被0除
except Exception as e:
    # 此处会对覆盖e，并删除e
    print(f'error info :{e}！')
print(e)
'''
输出：
error info :division by zero！
Traceback (most recent call last):
  File "c:\Users\jiang\Desktop\todo\1.py", line 7, in <module>
    print(e)
          ^
NameError: name 'e' is not defined
'''
```

下面的代码更有可能在生产环境中出现，原理相同，报错信息同样为：`NameError: name 'e' is not defined`

```python showLineNumbers
try:
    e = eval(input("please input 0/0:"))
except Exception as e:
    pass
finally:
    print(e)
```
:::

## 内置函数

以下函数大多为操作序列与控制流一起使用。

### any函数、all函数

any函数和all函数用于判断一个序列中的元素是否都为真或有一个为真。通常与if语句一起使用。

any函数签名：`any(iterable) -> bool`

all函数签名：`all(iterable) -> bool`

参数说明：
- `iterable`：要判断的序列

返回值：
- any函数返回一个布尔值，如果序列中有一个元素为真，则返回True，否则返回False
- all函数返回一个布尔值，如果序列中所有元素都为真，则返回True，否则返回False


```python showLineNumbers
a = 10
b = -5
c = 0
print(all([a,b,c])) # False,都为真时为真
print(any([a,b,c])) # True,有一个为真时为真
```

### range函数

range函数签名：`range(start, stop, step) -> range`

参数说明：
- `start`：起始值（可省略，默认为0）
- `stop`：结束值
- `step`：步长(可省略，默认为1，可正可负)

返回值：
- 返回一个range对象

```python showLineNumbers
for _ in range(10, 20, 2):
    print(_) 
# 10
# 12
# 14

for _ in range(10,0,-2):
    print(_) 
# 8
# 6
# 4
# 2
# 0
```

### enumerate函数

enumerate函数用于遍历序列，同时获取序列的序号和值。

enumerate函数签名：`enumerate(iterable, start=0) -> enumerate`

参数说明：
- `iterable`：要遍历的序列
- `start`：起始序号（可省略，默认为0）

返回值：
- 返回一个enumerate对象

```python showLineNumbers
for i, v in enumerate(['tic', 'tac', 'toe']):
    print(i, v)
# 0 tic
# 1 tac
# 2 toe

for i, v in enumerate(['tic', 'tac', 'toe'], start=1):
    print(i, v)
# 1 tic
# 2 tac
# 3 toe
```

### zip函数

zip函数用于将多个序列的元素一一配对，返回一个zip对象。

zip函数签名：`zip(iterable1, iterable2, ...) -> zip`

参数说明：
- `iterable1, iterable2, ...`：要配对的序列

返回值：
- 返回一个zip对象

```python showLineNumbers
list_a = [1, 2, 3]
list_b = [4, 5, 6]
for a, b in zip(list_a, list_b):
    print(a, b)
# 1 4
# 2 5
# 3 6
```