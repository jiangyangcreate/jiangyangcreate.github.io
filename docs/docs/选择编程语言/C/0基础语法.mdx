---
sidebar_position: 0
title: 基础语法
---

## main函数

一个 C 语言程序**有且只有一个main函数**，程序运行时系统会**自动调用**。

如果一个程序没有main函数，则这个程序不具备运行能力。如果一个程序有多个main函数，则编译时会报错。

### 函数定义格式

- main函数定义的格式:
  - `int` 代表函数执行之后会返回一个整数类型的值
  - `main` 代表这个函数的名字叫做 main
  - `()` 代表这是一个函数
  - `{}` 代表这个程序段的范围
  - `return 0;` 代表函数执行完之后返回整数 0

```c showLineNumbers
int main() {
    // insert code here...
    return 0;
}
```
:::info
- C 语言中,每条完整的语句后面都必须以<Highlight>英文分号</Highlight>结尾
- main 函数前面的 int 可以不写或换成 void
- main 函数中的 return 0 可以不写
:::

- 其它函数定义的格式
  - `int` 代表函数执行之后会返回一个整数类型的值
  - `call` 代表这个函数的名字叫做 call
  - `()`代表这是一个函数
  - `{}` 代表这个程序段的范围
  - `return 0;` 代表函数执行完之后返回整数 0

```c showLineNumbers
int call() {
    return 0;
}
```

:::info

- main函数会由系统自动调用, 其它函数需要开发者**在 main 函数中手动调用**。
  - call 代表找到名称叫做 call 的某个东西
  - () 代表要找到的名称叫 call 的某个东西是一个函数
  - ; 代表调用函数的语句已经编写完成
  - 所以 `call();`代表找到 call 函数, 并执行 call 函数

```c showLineNumbers
int call() {
    return 0;
}
int main() {
    call();
}
```
:::

## 注释

注释是代码中不会被解释器执行的文本。用于解释代码，方便阅读。

C 支持`//单行注释` 和 `/* 多行注释 */`

```c showLineNumbers
// 单行注释
// 以//开头，到这一行末尾
// 任何地方都可以写注释：函数外面、里面，每一条语句后面
// 快捷键:Ctrl+/


/*
// 多行注释可以嵌套单行注释

多行注释不能嵌套多行注释

因为多行注释以/*开头，到最近的一个* /结尾

初学者编写程序可以养成习惯：先写注释再写代码
将自己的思想通过注释先整理出来，在用代码去体现
因为代码仅仅是思想的一种体现形式而已
*/
```
## 内置内容

C语言的核心设计理念是<Highlight>小而精</Highlight>，它只提供了一套非常精简的内置功能，将大部分功能都留给库来实现。

### 关键字

关键字是语言中预先定义的标识符。(在开发工具中会显示特殊颜色。)

我们把它们用作标识符名称会引发错误或导致其功能失效。

<MarkmapHooks initialMarkdown={`

## C语言关键字

### 数据类型与修饰符
- char: 字符类型
- short: 短整型
- int: 整型
- float: 单精度浮点型
- double: 双精度浮点型
- void: 空类型
- long: 长度修饰符（单写等同于 long int)
- signed: 有符号类型
- unsigned: 无符号类型
- const: 常量修饰符
- volatile: 易变修饰符
- enum: 枚举类型

### 运算符
- sizeof: 计算类型或变量大小

### 控制流程

#### 选择结构
- if: 条件判断
- else: 否则条件
- switch: 多分支选择
- case: switch中的分支
- default: switch中的默认分支

### 循环结构
- for: for循环
- while: while循环
- do: do-while循环

### 跳转语句
- break: 跳出循环或switch
- continue: 继续下一次循环
- goto: 无条件跳转
- return: 函数返回

### 构造数据
- struct: 结构体
- union: 联合体
- typedef: 类型定义

### 存储类别
- auto: 自动存储类别
- register: 寄存器存储类别
- static: 静态存储类别
- extern: 外部存储类别
`} />

### 数据类型

- **作为程序员, 我们最关心的是内存中的动态数据**,因为我们写的程序就是在内存中运行的
- 程序在运行过程中会产生各种各样的临时数据,**为了方便数据的运算和操作, C 语言对这些数据进行了分类**, 提供了丰富的数据类型
- C 语言中有 4 大类数据类型:**基本类型、空类型、构造类型、指针类型**

<MarkmapHooks initialMarkdown={`

## C语言数据类型

### 基本类型
#### 整型
- char: 字符型（1字节）
  - signed char: 有符号字符 (-128~127)
  - unsigned char: 无符号字符 (0~255)
- short: 短整型（2字节）
  - signed short: 有符号短整型 (-32768~32767)  
  - unsigned short: 无符号短整型 (0~65535)
- int: 整型（通常4字节）
  - signed int: 有符号整型
  - unsigned int: 无符号整型
- long: 长整型（通常4或8字节）
  - signed long: 有符号长整型
  - unsigned long: 无符号长整型
- long long: 长长整型（8字节）
  - signed long long: 有符号长长整型
  - unsigned long long: 无符号长长整型

#### 浮点型
- float: 单精度浮点型（4字节）
  - 精度: 约6-7位有效数字
  - 范围: ±3.4E±38
- double: 双精度浮点型（8字节）
  - 精度: 约15-16位有效数字
  - 范围: ±1.7E±308
- long double: 扩展精度浮点型
  - 精度和范围依赖于编译器

#### 枚举类型
- enum: 命名的整型常量集合
- 本质上也是基本数据类型
- 提高代码可读性
- 编译时替换为整型值

### 空类型
#### void类型
- void: 无类型
- 用于函数无返回值
- 用于通用指针类型
- 不能定义void类型变量

### 构造类型

#### 数组类型
- 一维数组: type array[size]
- 多维数组: type array[row][col]
- 字符数组: char str[size]

#### 结构体类型
- struct: 用户自定义类型
- 成员可以是不同数据类型
- 内存连续存储

#### 联合体类型
- union: 共享内存的数据类型
- 所有成员共用同一内存空间
- 大小为最大成员的大小

### 指针类型
#### 基本指针
- int *: 指向整型的指针
- char *: 指向字符的指针
- void *: 通用指针类型

#### 复合指针
- 指针数组: type *array[size]
- 数组指针: type (*ptr)[size]
- 函数指针: type (*ptr)(params)
- 指向指针的指针: type **ptr


### 类型修饰符
#### 存储类修饰符
- auto: 自动变量（局部变量默认）
- static: 静态变量
- extern: 外部变量
- register: 寄存器变量

#### 类型限定符
- const: 常量修饰符
- volatile: 易变修饰符
- restrict: 限制修饰符（C99）

`} />

1个二进制位可以存储0或1，称为<HoverText text="位" explanation="binary digit 简称bit" />。

8个二进制位就可以存储2^8=256个不同的数值（0~255），称为<HoverText text="字节" explanation="byte" />。

在计算机中以整数形式存储的就是整型。字符型（char）本质上也是小整数（通常对应ASCII码值），所以字符型也属于整型家族，可以进行算术运算。

:::tip 数据类型使用建议
1. **选择合适的类型**：根据数据范围选择最小满足需求的类型
2. **避免溢出**：注意数据范围，防止溢出导致的错误结果  
3. **浮点数比较**：不要直接用==比较浮点数，使用epsilon比较
4. **类型转换**：明确类型转换的规则，避免精度丢失
5. **内存对齐**：了解结构体内存对齐规则，优化内存使用
:::

:::warning 常见陷阱
- **整数除法截断**：`5/2` 结果是 `2` 而不是 `2.5`
- **无符号整数下溢**：`unsigned int x = 0; x--;` 结果是很大的正数
- **浮点精度问题**：`0.1 + 0.2` 可能不等于 `0.3`
- **数组越界**：访问数组时要检查边界，C语言不会自动检查
:::


### 标准库

虽然C语言的内置内容少，但它拥有一个庞大且功能强大的标准库 (Standard Library)，这是C语言功能的核心所在。

这个标准库被分成了许多头文件，每个头文件都包含了一组相关的函数、宏和类型定义。

标准库的设计理念是精简(基本功能)、高效（通用功能）和可移植（与操作系统无关的）。

<MarkmapHooks initialMarkdown={`

## C语言标准库

### 输入输出处理
#### stdio.h - 标准输入输出
- printf: 格式化输出
- scanf: 格式化输入
- puts: 输出字符串
- gets: 读取字符串
- putchar: 输出字符
- getchar: 读取字符
- fopen: 打开文件
- fclose: 关闭文件
- fread: 读取文件
- fwrite: 写入文件
- fprintf: 文件格式化输出
- fscanf: 文件格式化输入
- fseek: 文件定位
- ftell: 获取文件位置

### 内存和工具管理
#### stdlib.h - 标准工具库
- malloc: 动态内存分配
- calloc: 清零内存分配
- realloc: 重新分配内存
- free: 释放内存
- exit: 退出程序
- abort: 异常终止
- system: 执行系统命令
- atoi: 字符串转整数
- atof: 字符串转浮点数
- rand: 随机数生成
- srand: 设置随机种子
- qsort: 快速排序
- bsearch: 二分查找

### 字符串处理
#### string.h - 字符串操作
- strlen: 计算字符串长度
- strcpy: 复制字符串
- strcat: 连接字符串
- strcmp: 比较字符串
- strchr: 查找字符
- strstr: 查找子字符串
- strncpy: 安全复制字符串
- strncat: 安全连接字符串
- strncmp: 安全比较字符串
- memset: 内存设置
- memcpy: 内存复制
- memcmp: 内存比较

### 数学计算
#### math.h - 数学函数
- sin: 正弦函数
- cos: 余弦函数
- tan: 正切函数
- asin: 反正弦
- acos: 反余弦
- atan: 反正切
- sqrt: 平方根
- pow: 幂运算
- exp: 指数函数
- log: 自然对数
- log10: 常用对数
- ceil: 向上取整
- floor: 向下取整
- fabs: 绝对值

### 字符处理
#### ctype.h - 字符类型检查
- isalpha: 是否为字母
- isdigit: 是否为数字
- isalnum: 是否为字母或数字
- isspace: 是否为空格字符
- islower: 是否为小写字母
- isupper: 是否为大写字母
- tolower: 转为小写
- toupper: 转为大写
- isprint: 是否可打印
- ispunct: 是否为标点符号

### 时间处理
#### time.h - 时间和日期
- time: 获取当前时间
- clock: 获取处理器时间
- difftime: 计算时间差
- mktime: 创建时间结构
- asctime: 时间转字符串
- ctime: 时间戳转字符串
- gmtime: 转GMT时间
- localtime: 转本地时间
- strftime: 格式化时间字符串

### 系统相关
#### signal.h - 信号处理
- signal: 设置信号处理函数
- raise: 发送信号
- SIGINT: 中断信号
- SIGTERM: 终止信号
- SIGABRT: 异常终止信号
- SIGFPE: 浮点异常信号

#### errno.h - 错误处理
- errno: 全局错误号
- EDOM: 数学域错误
- ERANGE: 数学范围错误
- perror: 打印错误信息
- strerror: 获取错误信息字符串

### 高级功能
#### setjmp.h - 非局部跳转
- setjmp: 设置跳转点
- longjmp: 执行跳转

#### stdarg.h - 可变参数
- va_list: 参数列表类型
- va_start: 开始访问参数
- va_arg: 获取下一参数
- va_end: 结束参数访问

### 常量定义
#### limits.h - 数值极限
- INT_MAX: 整型最大值
- INT_MIN: 整型最小值
- CHAR_MAX: 字符最大值
- LONG_MAX: 长整型最大值

#### float.h - 浮点极限
- FLT_MAX: 浮点型最大值
- FLT_MIN: 浮点型最小正值
- DBL_MAX: 双精度最大值
- FLT_EPSILON: 浮点精度

#### stddef.h - 标准定义
- NULL: 空指针常量
- size_t: 无符号整型
- ptrdiff_t: 指针差值类型
- wchar_t: 宽字符类型

### 调试工具
#### assert.h - 断言
- assert: 断言宏
- NDEBUG: 禁用断言标志

#### locale.h - 本地化
- setlocale: 设置本地化信息
- localeconv: 获取本地化信息

`} />



## 运算符

运算符和关键字一样，可以直接使用。

### 算术运算符

| 优先级 | 名称                  | 符号 | 说明                    |
| ------ | --------------------- | ---- | ----------------------- |
| 3      | 乘法运算符            | \*   | 双目运算符,具有左结合性 |
| 3      | 除法运算符            | /    | 向零取整 |
| 3      | 求余运算符 (模运算符)   | %    | 双目运算符,具有左结合性 |
| 4      | 加法运算符            | +    | 双目运算符,具有左结合性 |
| 4      | 减法运算符            | -    | 双目运算符,具有左结合性 |

- 注意事项
  - 如果参与运算的两个操作数皆为整数, 那么结果也为整数
  - 如果参与运算的两个操作数其中一个是浮点数, 那么结果一定是浮点数
  - 求余运算符, 被除数a `%` 除数b, `a=(a 整除 b) × b + 余数` ，其中`(a 整除 b)`的结果总是向 0 取整。（四舍五入时也总是向 0 取整）
  - 求余运算符, 参与运算的两个操作数必须都是整数, 不能包含浮点数。且除数不能为 0 (没有意义)

```c showLineNumbers
#include <stdio.h>
int main(){
    int a = 10;
    int b = 5;
    // 加法
    int result = a + b;
    printf("%i\n", result); // 15
    // 减法
    result = a - b;
    printf("%i\n", result); // 5
    // 乘法
    result = a * b;
    printf("%i\n", result); // 50
    // 除法
    result = a / b;
    printf("%i\n", result); // 2

    // 算术运算符的结合性和优先级
    // 结合性: 左结合性, 从左至右
    int c = 50;
    result = a + b + c; // 15 + c;  65;
    printf("%i\n", result);

    // 优先级: * / % 大于 + -
    result = a + b * c; // a + 250; 260;
    printf("%i\n", result);

    // 整数除以整数, 结果还是整数
    printf("%i\n", 10 / 3); // 3

    // 参与运算的任何一个数是小数, 结果就是小数
    printf("%f\n", 10 / 3.0); // 3.333333

    // 10 / 3 商等于3, 余1
    int result_2 = 10 % 3;
    printf("%i\n", result_2); // 1

    // 左边小于右边, 那么结果就是左边
    result_2 = 2 % 10;
    printf("%i\n", result_2); // 2

    // 被除数是正数结果就是正数,被除数是负数结果就是负数
    result_2 = 10 % 3;
    printf("%i\n", result_2); // 1
    result_2 = -10 % 3;
    printf("%i\n", result_2); // -1
    result_2 = 10 % -3;
    printf("%i\n", result_2); // 1
}
```

### 赋值运算符

| 优先级 | 名称                      | 符号 | 说明                    |
| ------ | ------------------------- | ---- | ----------------------- |
| 14     | 赋值运算符                | =    | 双目运算符,具有右结合性 |
| 14     | 除后赋值运算符            | /=   | 双目运算符,具有右结合性 |
| 14     | 乘后赋值运算符 (模运算符) | \*=  | 双目运算符,具有右结合性 |
| 14     | 取模后赋值运算符          | %=   | 双目运算符,具有右结合性 |
| 14     | 加后赋值运算符            | +=   | 双目运算符,具有右结合性 |
| 14     | 减后赋值运算符            | -=   | 双目运算符,具有右结合性 |

- 简单赋值运算符

```c showLineNumbers
#include <stdio.h>
int main(){
    // 简单的赋值运算符 =
    // 会将=右边的值赋值给左边
    int a = 10;
    printf("a = %i\n", a); // 10
}
```

- 复合赋值运算符

```c showLineNumbers
#include <stdio.h>
int main(){
     // 复合赋值运算符 += -= *= /= %=
     // 将变量中的值取出之后进行对应的操作, 操作完毕之后再重新赋值给变量
     int num1 = 10;
     // num1 = num1 + 1; num1 = 10 + 1; num1 = 11;
     num1 += 1;
     printf("num1 = %i\n", num1); // 11
     int num2 = 10;
     // num2 = num2 - 1; num2 = 10 - 1; num2 = 9;
     num2 -= 1;
     printf("num2 = %i\n", num2); // 9
     int num3 = 10;
     // num3 = num3 * 2; num3 = 10 * 2; num3 = 20;
     num3 *= 2;
     printf("num3 = %i\n", num3); // 20
     int num4 = 10;
     // num4 = num4 / 2; num4 = 10 / 2; num4 = 5;
     num4 /= 2;
     printf("num4 = %i\n", num4); // 5
     int num5 = 10;
     // num5 = num5 % 3; num5 = 10 % 3; num5 = 1;
     num5 %= 3;
     printf("num5 = %i\n", num5); // 1
}
```

- 结合性和优先级

```c showLineNumbers
#include <stdio.h>
int main(){
    int number = 10;
    // 赋值运算符优先级是14, 普通运算符优先级是3和4, 所以先计算普通运算符
    // 普通运算符中乘法优先级是3, 加法是4, 所以先计算乘法
    // number += 1 + 25; number += 26; number = number + 26; number = 36;
    number += 1 + 5 * 5;
    printf("number = %i\n", number); // 36
}
```

### 自增自减运算符

- 在程序设计中,经常遇到“i=i+1”和“i=i-1”这两种极为常用的操作。
- C 语言为这种操作提供了两个更为简洁的运算符,即++和--

| 优先级 | 名称             | 符号 | 说明                    |
| ------ | ---------------- | ---- | ----------------------- |
| 2      | 自增运算符(在后) | i++  | 单目运算符,具有左结合性 |
| 2      | 自增运算符(在前) | ++i  | 单目运算符,具有右结合性 |
| 2      | 自减运算符(在后) | i--  | 单目运算符,具有左结合性 |
| 2      | 自减运算符(在前) | --i  | 单目运算符,具有右结合性 |


- 自增
  - 如果只有**_单个_**变量, 无论++写在前面还是后面都会对变量做+1 操作

```c showLineNumbers
#include <stdio.h>
int main(){
    int number = 10;
    number++;
    printf("number = %i\n", number); // 11
    ++number;
    printf("number = %i\n", number); // 12
}
```

- 如果出现在一个表达式中, 那么++写在前面和后面就会有所区别
  - 前缀表达式:++x, --x;其中 x 表示变量名,先完成变量的自增自减 1 运算,再用 x 的值作为表达式的值;即“先变后用”,也就是变量的值先变,再用变量的值参与运算
  - 后缀表达式:x++, x--;先用 x 的当前值作为表达式的值,再进行自增自减 1 运算。即“先用后变”,也就是先用变量的值参与运算,变量的值再进行自增自减变化

```c showLineNumbers
#include <stdio.h>
int main(){
    int number = 10;
    // ++在后, 先参与表达式运算, 再自增
    // 表达式运算时为: 3 + 10;
    int result = 3 + number++;
    printf("result = %i\n", result); // 13
    printf("number = %i\n", number); // 11
}
```

```c showLineNumbers
#include <stdio.h>
int main(){
    int number = 10;
    // ++在前, 先自增, 再参与表达式运算
    // 表达式运算时为: 3 + 11;
    int result = 3 + ++number;
    printf("result = %i\n", result); // 14
    printf("number = %i\n", number); // 11
}
```

- 自减

```c showLineNumbers
#include <stdio.h>
int main(){
    int number = 10;
    // --在后, 先参与表达式运算, 再自减
    // 表达式运算时为: 10 + 3;
    int result = number-- + 3;
    printf("result = %i\n", result); // 13
    printf("number = %i\n", number); // 9
}
```

```c showLineNumbers
#include <stdio.h>
int main(){
    int number = 10;
    // --在前, 先自减, 再参与表达式运算
    // 表达式运算时为: 9 + 3;
    int result = --number + 3;
    printf("result = %i\n", result); // 12
    printf("number = %i\n", number); // 9
}
```

- 注意点:
  - 自增、自减运算只能用于单个变量,只要是标准类型的变量,不管是整型、实型,还是字符型变量等,但不能用于表达式或常量
    - 错误用法: `++(a+b); 5++;`
  - 企业开发中尽量让++ -- 单独出现, 尽量不要和其它运算符混合在一起

```c showLineNumbers
int i = 10;
int b = i++; // 不推荐
或者
int b = ++i; // 不推荐
或者
int a = 10;
int b = ++a + a++;  // 不推荐
```

- 请用如下代码替代

```c showLineNumbers
int i = 10;
int b = i; // 推荐
i++;
或者;
i++;
int b = i; // 推荐
或者
int a = 10;
++a;
int b = a + a; // 推荐
a++;
```

- C 语言标准没有明确的规定，`同一个表达式中同一个变量自增或自减后如何运算`, 不同编译器得到结果也不同, 在企业开发中千万不要这样写

```c showLineNumbers
    int a = 1;
    // 下列代码利用Qt运行时6, 利用Xcode运行是5
    // 但是无论如何, 最终a的值都是3
   //  在C语言中这种代码没有意义, 不用深究也不要这样写
   // 特点: 参与运算的是同一个变量, 参与运算时都做了自增自减操作, 并且在同一个表达式中
    int b = ++a + ++a;
    printf("b = %i\n", b);
```

### sizeof 运算符

- sizeof 可以用来计算一个变量或常量、数据类型所占的内存字节数

  - 标准格式: sizeof(常量 or 变量);

- sizeof 的几种形式

  - sizeof( 变量\常量 );
    - `sizeof(10);`
    - `char c = 'a'; sizeof(c);`
  - sizeof 变量\常量;
    - `sizeof 10;`
    - `char c = 'a'; sizeof c;`
  - sizeof( 数据类型);
    - `sizeof(float);`
    - `如果是数据类型不能省略括号`

- sizeof 面试题:
  - sizeof()和+=、\*=一样是一个复合运算符, 由 sizeof 和()两个部分组成, 但是代表的是一个整体
  - 所以 sizeof 不是一个函数, 是一个运算符, 该运算符的优先级是 2

```c showLineNumbers
#include <stdio.h>
int main(){
    int a = 10;
    double b = 3.14;
    // 由于sizeof的优先级比+号高, 所以会先计算sizeof(a);
    // a是int类型, 所以占4个字节得到结果4
    // 然后再利用计算结果和b相加, 4 + 3.14 = 7.14
    double res = sizeof a+b;
    printf("res = %lf\n", res); // 7.14
}
```

### 逗号运算符

- 在 C 语言中逗号“,”也是一种运算符,称为逗号运算符。 其功能是把多个表达式连接起来组成一个表达式,称为逗号表达式
- 逗号运算符会从左至右依次取出每个表达式的值, 最后整个逗号表达式的值等于最后一个表达式的值
- 格式: `表达式1，表达式2，… …，表达式n;`

* 例如: `int result = a+1,b=3*4;`

```c showLineNumbers
#include <stdio.h>
int main(){
    int a = 10, b = 20, c;
    // ()优先级高于逗号运算符和赋值运算符, 所以先计算()中的内容
    // c = (11, 21);
    // ()中是一个逗号表达式, 结果是最后一个表达式的值, 所以计算结果为21
    // 将逗号表达式的结果赋值给c, 所以c的结果是21
    c = (a + 1, b + 1);
    printf("c = %i\n", c); // 21
}
```

### 关系运算符

- 为什么要学习关系运算符

* 默认情况下，我们在程序中写的每一句正确代码都会被执行。但很多时候，我们想在某个条件成立的情况下才执行某一段代码
* 这种情况的话可以使用条件语句来完成，但是学习条件语句之前，我们先来看一些更基础的知识：如何判断一个条件是否成立

- C 语言中的真假性

* 在 C 语言中，条件成立称为“真”，条件不成立称为“假”，因此，判断条件是否成立，就是判断条件的“真假”
* 怎么判断真假呢？C 语言规定，任何数值都有真假性，任何非 0 值都为“真”，只有 0 才为“假”。也就是说，108、-18、4.5、-10.5 等都是“真”，0 则是“假”


- 关系运算符的运算结果只有 2 种：如果条件成立，结果就为 1，也就是“真”；如果条件不成立，结果就为 0，也就是“假”

| 优先级 | 名称           | 符号 | 说明                    |
| ------ | -------------- | ---- | ----------------------- |
| 6      | 大于运算符     | `>`  | 双目运算符,具有左结合性 |
| 6      | 小于运算符     | `<`  | 双目运算符,具有左结合性 |
| 6      | 大于等于运算符 | `>=` | 双目运算符,具有左结合性 |
| 6      | 小于等于运算符 | `<=` | 双目运算符,具有左结合性 |
| 7      | 等于运算符     | ==   | 双目运算符,具有左结合性 |
| 7      | 不等于运算符   | !=   | 双目运算符,具有左结合性 |

```c showLineNumbers
#include <stdio.h>
int main(){
    int result = 10 > 5;
    printf("result = %i\n", result); // 1
    result = 5 < 10;
    printf("result = %i\n", result); // 1
    result = 5 > 10;
    printf("result = %i\n", result); // 0
    result = 10 >= 10;
    printf("result = %i\n", result); // 1
    result = 10 <= 10;
    printf("result = %i\n", result); // 1
    result = 10 == 10;
    printf("result = %i\n", result); // 1
    result = 10 != 9;
    printf("result = %i\n", result); // 1
}
```

- 优先级和结合性

```c showLineNumbers
#include <stdio.h>
int main(){
    // == 优先级 小于 >, 所以先计算>
    // result = 10 == 1; result = 0;
    int result = 10 == 5 > 3;
    printf("result = %i\n", result); // 0
}
```

```c showLineNumbers
#include <stdio.h>
int main(){
    // == 和 != 优先级一样, 所以按照结合性
    // 关系运算符是左结合性, 所以从左至右计算
    // result = 0 != 3; result = 1;
    int result = 10 == 5 != 3;
    printf("result = %i\n", result); // 1
}
```


- 注意点:
  - 无论是 float 还是 double 都有精度问题, 所以一定要避免利用==判断浮点数是否相等

```c showLineNumbers
#include <stdio.h>
int main(){
    float a = 0.1;
    float b = a * 10 + 0.00000000001;
    double c = 1.0 + + 0.00000000001;
    printf("b = %f\n", b);
    printf("c = %f\n", c);
    int result = b == c;
    printf("result = %i\n", result); // 0
}
```
### 逻辑运算符

| 优先级 | 名称         | 符号   | 说明                    |
| ------ | ------------ | ------ | ----------------------- |
| 2      | 逻辑非运算符 | !      | 单目运算符,具有右结合性 |
| 11     | 逻辑与运算符 | &&     | 双目运算符,具有左结合性 |
| 12     | 逻辑或运算符 | `\|\|` | 双目运算符,具有左结合性 |

- 逻辑非

* 格式: `! 条件A;`

* 运算结果: 真变假,假变真

* 运算过程:

  - 先判断条件 A 是否成立，如果添加 A 成立, 那么结果就为 0，即“假”；
  - 如果条件 A 不成立，结果就为 1，即“真”

  * 使用注意:

  - 可以多次连续使用逻辑非运算符
  - !!!0;相当于(!(!(!0)));最终结果为 1

```c showLineNumbers
#include <stdio.h>
int main(){
    // ()优先级高, 先计算()里面的内容
    // 10==10为真, 所以result = !(1);
    // !代表真变假, 假变真,所以结果是假0
    int result = !(10 == 10);
    printf("result = %i\n", result); // 0
}
```

- 逻辑与

  - 格式: `条件A && 条件B;`
  - 运算结果:一假则假
  - 运算过程:

  * 总是先判断"条件 A"是否成立
  * 如果"条件 A"成立，接着再判断"条件 B"是否成立, 如果"条件 B"也成立，结果就为 1，即“真”
  * 如果"条件 A"成立，"条件 B"不成立，结果就为 0，即“假”
  * 如果"条件 A"不成立，不会再去判断"条件 B"是否成立, 因为逻辑与只要一个不为真结果都不为真

  - 使用注意:

  * "条件 A"为假, "条件 B"不会被执行

```c showLineNumbers
#include <stdio.h>
int main(){
    //               真     &&    真
    int result = (10 == 10) && (5 != 1);
    printf("result = %i\n", result); // 1
    //          假     &&    真
    result = (10 == 9) && (5 != 1);
    printf("result = %i\n", result); // 0
    //          真     &&    假
    result = (10 == 10) && (5 != 5);
    printf("result = %i\n", result); // 0
    //          假     &&    假
    result = (10 == 9) && (5 != 5);
    printf("result = %i\n", result); // 0
}
```

```c showLineNumbers
#include <stdio.h>
int main(){
    int a = 10;
    int b = 20;
    // 逻辑与, 前面为假, 不会继续执行后面
    int result = (a == 9) && (++b);
    printf("result = %i\n", result); // 1
    printf("b = %i\n", b); // 20
}
```

- 逻辑或

  - 格式: `条件A || 条件B;`
  - 运算结果:一真则真
  - 运算过程:

  * 总是先判断"条件 A"是否成立
  * 如果"条件 A"不成立，接着再判断"条件 B"是否成立, 如果"条件 B"成立，结果就为 1，即“真”
  * 如果"条件 A"不成立，"条件 B"也不成立成立, 结果就为 0，即“假”
  * 如果"条件 A"成立, 不会再去判断"条件 B"是否成立, 因为逻辑或只要一个为真结果都为真

  - 使用注意:

  * "条件 A"为真, "条件 B"不会被执行

```c showLineNumbers
#include <stdio.h>
int main(){
    //               真     ||    真
    int result = (10 == 10) || (5 != 1);
    printf("result = %i\n", result); // 1
    //          假     ||    真
    result = (10 == 9) || (5 != 1);
    printf("result = %i\n", result); // 1
    //          真     ||    假
    result = (10 == 10) || (5 != 5);
    printf("result = %i\n", result); // 1
    //          假     ||    假
    result = (10 == 9) || (5 != 5);
    printf("result = %i\n", result); // 0
}
```

```c showLineNumbers
#include <stdio.h>
int main(){
    int a = 10;
    int b = 20;
    // 逻辑或, 前面为真, 不会继续执行后面
    int result = (a == 10) || (++b);
    printf("result = %i\n", result); // 1
    printf("b = %i\n", b); // 20
}
```


### 位运算符

- 程序中的所有数据在计算机内存中都是以二进制的形式储存的。
- 位运算就是直接对整数在内存中的二进制位进行操作
- C 语言提供了 6 个位操作运算符, 这些运算符只能用于整型操作数

| 符号 | 名称     | 运算结果         |
| ---- | -------- | ---------------- |
| &    | 按位与   | 同 1 为 1        |
| \|   | 按位或   | 有 1 为 1        |
| ^    | 按位异或 | 不同为 1         |
| ~    | 按位取反 | 0 变 1,1 变 0    |
| `<<` | 按位左移 | 乘以 2 的 n 次方 |
| `>>` | 按位右移 | 除以 2 的 n 次方 |

---

- 按位与:
  - 只有对应的两个二进位均为 1 时，结果位才为 1，否则为 0
  - 规律: 二进制中，与 1 相&就保持原位，与 0 相&就为 0

```bash showLineNumbers
9&5 = 1

 1001
&0101
------
 0001
```

---

- 按位或:
  - 只要对应的二个二进位有一个为 1 时，结果位就为 1，否则为 0

```c showLineNumbers
9|5 = 13

 1001
|0101
------
 1101
```

---

- 按位异或
  - 当对应的二进位相异（不相同）时，结果为 1，否则为 0
  - 规律:
    - 相同整数相的结果是 0。比如 55=0
    - 多个整数相^的结果跟顺序无关。例如: 567=576
    - 同一个数异或另外一个数两次, 结果还是那个数。例如: 577 = 5

```c showLineNumbers
9^5 = 12

 1001
^0101
------
 1100
```

---

- 按位取反
  - 各二进位进行取反（0 变 1，1 变 0）

```c showLineNumbers
~9 =-10
0000 0000 0000 0000 0000 1001 // 取反前
1111 1111 1111 1111 1111 0110 // 取反后

// 根据负数补码得出结果
1111 1111 1111 1111 1111 0110 // 补码
1111 1111 1111 1111 1111 0101 // 反码
1000 0000 0000 0000 0000 1010 // 源码 == -10
```

### 三目运算符

- 三目运算符，它需要 3 个数据或表达式构成条件表达式
- 格式: `表达式1？表达式2(结果A)：表达式3(结果B)`

* 示例: `考试及格 ? 及格 : 不及格;`

- 求值规则:

* 如果"表达式 1"为真，三目运算符的运算结果为"表达式 2"的值(结果 A)，否则为"表达式 3"的值(结果 B)

```c showLineNumbers
示例:
    int a = 10;
    int b = 20;
    int max = (a > b) ? a : b;
    printf("max = %d", max);
    输出结果: 20
等价于:
    int a = 10;
    int b = 20;
    int max = 0;
    if(a>b){
      max=a;
    }else {
       max=b;
    }
    printf("max = %d", max);
```

- 注意点

* 条件运算符的运算优先级低于关系运算符和算术运算符,但高于赋值符
* 条件运算符?和:是一个整体,不能分开使用

```c showLineNumbers
#include <stdio.h>
int main(){
    int a = 10;
    int b = 5;
    // 先计算 a > b
    // 然后再根据计算结果判定返回a还是b
    // 相当于int max= (a>b) ? a : b;
    int max= a>b ? a : b;
    printf("max = %i\n", max); // 10
}
```

```c showLineNumbers
#include <stdio.h>
int main(){
    int a = 10;
    int b = 5;
    int c = 20;
    int d = 10;
    // 结合性是从右至左, 所以会先计算:后面的内容
    // int res = a>b?a:(c>d?c:d);
    // int res = a>b?a:(20>10?20:10);
    // int res = a>b?a:(20);
    // 然后再计算最终的结果
    // int res = 10>5?10:(20);
    // int res = 10;
    int res = a>b?a:c>d?c:d;
    printf("res = %i\n", res);
}
```


### 运算符的优先级和结合性

早在小学的数学课本中,我们就学习过"从左往右,先乘除后加减,有括号的先算括号里面的", 这句话就蕴含了优先级和结合性的问题。

C 语言中,运算优先级1 级最高,15 级最低。相同优先级的运算符, 运算次序按照结合性规定的方向执行。

| 优先级 | 运算符 | 说明 | 结合性 |
| ------ | ------ | ---- | ------ |
| 1 | `()` `[]` `->` `.` | 圆括号(函数调用)、下标引用、指向结构体成员、结构体成员 | 从左到右 |
| 2 | `!` `~` `++` `--` `+` `-` `*` `&` `sizeof` `(type)` | 逻辑非、按位取反、自增自减、正负号、指针、取地址、长度、强制类型转换 | 从右到左 |
| 3 | `*` `/` `%` | 乘法、除法、取余 | 从左到右 |
| 4 | `+` `-` | 加法、减法 | 从左到右 |
| 5 | `<<` `>>` | 左移、右移 | 从左到右 |
| 6 | `<` `<=` `>` `>=` | 小于、小于等于、大于、大于等于 | 从左到右 |
| 7 | `==` `!=` | 等于、不等于 | 从左到右 |
| 8 | `&` | 按位与 | 从左到右 |
| 9 | `^` | 按位异或 | 从左到右 |
| 10 | `\|` | 按位或 | 从左到右 |
| 11 | `&&` | 逻辑与 | 从左到右 |
| 12 | `\|\|` | 逻辑或 | 从左到右 |
| 13 | `?:` | 条件运算符(三目运算符) | 从右到左 |
| 14 | `=` `+=` `-=` `*=` `/=` `%=` `&=` `^=` `\|=` `<<=` `>>=` | 各种赋值运算符 | 从右到左 |
| 15 | `,` | 逗号运算符 | 从左到右 |

:::tip 记忆技巧
1. 复杂表达式推荐使用括号`()`来明确运算顺序，提高代码可读性。
2. **大部分运算符从左到右**，只有单目运算符、三目运算符、赋值运算符是**从右到左**
:::

