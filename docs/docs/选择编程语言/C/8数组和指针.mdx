---
sidebar_position: 8
title: （编写中）⭐数组和指针
---

构造数据是指由用户可以定义的、非内置的数据类型。主要有数组、结构体、联合体。


## 数组

数组属于**构造数据类型**，是一组`相同类型`数据的`连续内存`集合。

数组的特点包括：

- 固定大小（编译时确定）
- 元素类型相同
- 内存连续分配
- 通过下标访问（从0开始）

前面提到的基本的数据类型又可以和数组结合，形成新的构造数据类型。这里不再逐一列举。

定义数组：`数据类型 数组名[数组长度];`

```c showLineNumbers
// int 元素类型
// ages 数组名称
// [10] 数组长度 即 元素个数
int ages[10];
// 数组名为ages, 数组类型为int [10]

int scores[5];     // 5个整数的数组
double temps[30];    // 30个双精度浮点数
char name[20];     // 20个字符的字符数组，也叫字符串
```


### 初始化数组

```c showLineNumbers
// 完全初始化, 其中在{ }中的各数据值即为各元素的初值,各值之间用逗号间隔
// 定义的同时可以初始化多个值
int ages[3] = {4, 6, 9};

// 完全初始化,不指定元素个数,自动计算长度
int days[] = {31,28,31,30,31};  // 自动确定为5个元素

// 部分初始化（剩余自动补0）
int arr[5] = {1, 2};     // [1, 2, 0, 0, 0]

// 部分初始化,指定位置的元素初始化
int nums[5] = {[0] = 1,[1] = 2}; // [1, 2, 0, 0, 0]


// 先定义后初始化
int nums[3];

nums[0] = 1;
nums[1] = 2;
nums[2] = 3;

int ages[3]; // 定义后只能逐个初始化值
ages = {4, 6, 9}; // 报错
```

如果定义数组后,<Highlight>没有初始化,数组中是随机的垃圾数</Highlight>,所以如果想要正确使用数组应该要进行初始化。


:::info

在定义数组的时候[]里面能写整型常量或者是返回整型常量的表达式

不能写变量。

```c showLineNumbers
#include <stdio.h>

int main() {
    int ages1['A'] = {19, 22, 33};// 'A' 会被转换为 65
    printf("ages1[0] = %d\n", ages1[0]);

    int ages2[5 + 5] = {19, 22, 33};
    printf("ages2[0] = %d\n", ages2[0]);

    int ages3['A' + 5] = {19, 22, 33};// 'A' + 5会被转换为 70
    printf("ages3[0] = %d\n", ages3[0]);

    printf("sizeof(ages3) = %lu\n", sizeof(ages3));// 大小为 70 * 4 = 280
}

```
:::

### 数组元素的访问

使用数组时不能超出数组的索引范围使用，索引从 0 开始，到元素个数-1 结束

通过下标（索引）访问：

```c showLineNumbers
int nums[3] = {10, 20, 30};
nums[0] = 15;       // 修改第一个元素
int x = nums[2];     // 读取第三个元素

// 越界访问
int arr[3];
arr[5] = 10;  // 未定义行为！可能破坏其他内存，导致程序崩溃
```

### 数组的遍历

遍历的意思就是有序地查看数组的每一个元素

```c showLineNumbers
#include <stdio.h>
int main() {
    
    int ages[4] = {11, 22, 33, 44};

    // 正序输出(遍历)数组
    for (int i = 0; i < 4; i++) {
        printf("ages[%d] = %d\n", i, ages[i]);
    }

    // 逆序输出(遍历)数组
    for (int i = 3; i >=0; i--) {
        printf("ages[%d] = %d\n", i, ages[i]);
    }

    return 0;
    }
```


### 数组的内存

因为数组在内存中占用的字节数取决于其存储的数据类型和数据的个数

数组所占用存储空间 = 一个元素所占用存储空间 x 元素个数（数组长度）

可以使用 `sizeof` 函数来计算数组所占用的存储总空间和元素所占用的空间，进一步可以计算出数组的长度

```c showLineNumbers
#include <stdio.h>
int main() {
    int ages[4] = {19, 22, 33};
    int length = sizeof(ages) / sizeof(ages[0]);
    printf("length = %d\n", length); 
    return 0;
}

```

- 内存寻址从大到小，**系统**从高地址开辟一块连续没有被使用的（栈）内存给数组
- 从分配的连续存储空间中，地址小的位置开始给每个元素分配空间
- 数组名指向整个存储空间最小的地址

```c showLineNumbers
#include <stdio.h>
int main()
{
    char cs[] = {'l','n','j'}; // 获得三个高地址。假设为：99、98、97
    // 数组名指向整个存储空间最小的地址
    printf("cs = %p\n", &cs);       // cs = 97
    // 数组元素指向每个元素的地址
    // 从分配的连续存储空间中, 地址小的位置开始给每个元素分配空间
    printf("cs[0] = %p\n", &cs[0]); // cs[0] = 97
    printf("cs[1] = %p\n", &cs[1]); // cs[1] = 98
    printf("cs[2] = %p\n", &cs[2]); // cs[2] = 99
    return 0;
}
```

:::info
系统自动分配的内存空间叫做栈。从高地址开始，依次向下分配。默认 1-8 MB。可调整到几十 MB，但不宜太大，因为每个线程都需要独立堆区（不用也占着），多线程会占用大量内存。

那么我们程序员则可以从下往上使用内存，叫做堆。使用堆时，系统不会自动分配内存，需要我们自己申请。（不超过系统实际可用内存大小）堆是共享的，实际用多少分配多少（不用别人可以用）。

使用堆的情况：需要大量内存/不知道需要多大内存/需要跨函数使用

栈和堆是同一块物理内存的不同逻辑区域，可以调整栈和堆的大小比例。

```
堆 = 公共仓库
  - 所有线程（工人）共享
  - 需要登记（加锁）才能拿东西
  - 容量大，但可能需要排队

栈 = 个人工具箱
  - 每个线程（工人）有自己的
  - 不需要跟别人抢
  - 空间小，但访问快
```

| 特性 | 栈（Stack） | 堆（Heap） |
|------|------------|-----------|
| **共享性** | 每线程独立 | 所有线程共享 |
| **空间分配** | 创建线程时预留 | 按需动态增长 |
| **多线程开销** | 线程数 × 栈大小 | 所有线程共用一个 |
| **线程安全** | 天然线程安全 | 需要同步机制 |
| **访问速度** | 快（无竞争） | 较慢（可能竞争） |
| **适用场景** | 临时变量、函数调用 | 共享数据、大对象 |
:::

### 数组和函数

数组可以作为函数的参数使用，数组用作函数参数有两种形式：
- 一种是把数组元素作为实参使用
- 一种是把数组名作为函数的形参和实参使用


- 数组的元素作为函数实参，与同类型的简单变量作为实参一样，如果是基本数据类型，那么形参的改变不影响实参

```c showLineNumbers
void change(int val)// int val = number
{
    val = 55;
}
int main(int argc, const char * argv[])
{
    int ages[3] = {1, 5, 8};
    printf("ages[0] = %d", ages[0]);// 1
    change(ages[0]);
    printf("ages[0] = %d", ages[0]);// 1
}
```

> - 用数组元素作函数参数不要求形参也必须是数组元素



### 数组名作为函数参数

- 在 C 语言中，数组名除作为变量的标识符之外，数组名还代表了该数组在内存中的起始地址，因此，当数组名作函数参数时，实参与形参之间不是"值传递"，而是"地址传递"
- 实参数组名将该数组的起始地址传递给形参数组，两个数组共享一段内存单元，系统不再为形参数组分配存储单元
- 既然两个数组共享一段内存单元，所以形参数组修改时，实参数组也同时被修改了

```c showLineNumbers
void change2(int array[3])// int array = 0ffd1
{
    array[0] = 88;
}
int main(int argc, const char * argv[])
{
    int ages[3] = {1, 5, 8};
    printf("ages[0] = %d", ages[0]);// 1
    change(ages);
    printf("ages[0] = %d", ages[0]);// 88
}
```


### 数组名作函数参数的注意点

- 在函数形参表中,允许不给出形参数组的长度

```c showLineNumbers
void change(int array[])
{
    array[0] = 88;
}
```

- 形参数组和实参数组的类型必须一致，否则将引起错误。

```c showLineNumbers
void prtArray(double array[3]) // 错误写法
{
    for (int i = 0; i < 3; i++) {
        printf("array[%d], %f", i, array[i]);
    }
}
int main(int argc, const char * argv[])
{
    int ages[3] = {1, 5, 8};
    prtArray(ages[0]);
}
```

- 当数组名作为函数参数时，因为自动转换为了指针类型，所以在函数中无法动态计算除数组的元素个数

```c showLineNumbers
void printArray(int array[])
{
    printf("printArray size = %lu\n", sizeof(array)); // 8
    int length = sizeof(array)/ sizeof(int); // 2
    printf("length = %d", length);
}
```


## 多维数组

### 二维数组

- 所谓二维数组就是一个一维数组的每个元素又被声明为一 维数组,从而构成二维数组. 可以说二维数组是特殊的一维数组。
- 示例:

```c showLineNumbers
int a[2][3] = { {80,75,92}, {61,65,71}};
```

- 格式:

* 数据类型 数组名[一维数组的个数][一维数组的元素个数]
* 其中"一维数组的个数"表示当前二维数组中包含多少个一维数组
* 其中"一维数组的元素个数"表示当前前二维数组中每个一维数组元素的个数


### 二维数组的初始化

- 二维数的初始化可分为两种:

* 定义的同时初始化
* 先定义后初始化

- 定义的同时初始化

```c showLineNumbers
int a[2][3]={ {80,75,92}, {61,65,71}};
```

- 先定义后初始化

```c showLineNumbers
int a[2][3];
a[0][0] = 80;
a[0][1] = 75;
a[0][2] = 92;
a[1][0] = 61;
a[1][1] = 65;
a[1][2] = 71;
```

- 按行分段赋值

```c showLineNumbers
int a[2][3]={ {80,75,92}, {61,65,71}};
```

- 按行连续赋值

```c showLineNumbers
int a[2][3]={ 80,75,92,61,65,71};
```

- 其它写法

* 完全初始化,可以省略第一维的长度

```c showLineNumbers
int a[][3]={{1,2,3},{4,5,6}};int a[][3]={1,2,3,4,5,6};
```

- 部分初始化,可以省略第一维的长度

```c showLineNumbers
int a[][3]={{1},{4,5}};int a[][3]={1,2,3,4};
```

> - 注意: 有些人可能想不明白，为什么可以省略行数，但不可以省略列数。也有人可能会问，可不可以只指定行数，但是省略列数？其实这个问题很简单，如果我们这样写：
>   `int a[2][] = {1, 2, 3, 4, 5, 6};  // 错误写法`
>   大家都知道，二维数组会先存放第 1 行的元素，由于不确定列数，也就是不确定第 1 行要存放多少个元素，所以这里会产生很多种情况，可能 1、2 是属于第 1 行的，也可能 1、2、3、4 是第一行的，甚至 1、2、3、4、5、6 全部都是属于第 1 行的

- 指定元素的初始化

```c showLineNumbers
int a[2][3]={[1][2]=10};int a[2][3]={[1]={1,2,3}}
```

### 二维数组的应用场景

象棋、围棋的棋子的表示。网格地图的数据表示。

### 二维数组的遍历和存储

### 二维数组的遍历

- 二维数组 a[3][4],可分解为三个一维数组,其数组名分别为:

* 这三个一维数组都有 4 个元素,例如:一维数组 a[0]的 元素为 a[0][0],a[0][1],a[0][2],a[0][3]。
* 所以遍历二维数组无非就是先取出二维数组中得一维数组, 然后再从一维数组中取出每个元素的值

- 示例

```c showLineNumbers
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("%c", cs[0][0]);// 第一个[0]取出一维数组, 第二个[0]取出一维数组中对应的元素
```

```c showLineNumbers
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    for (int i = 0; i < 2; i++) { // 外循环取出一维数组
        // i
        for (int j = 0; j < 3; j++) {// 内循环取出一维数组的每个元素
            printf("%c", cs[i][j]);
        }
        printf("\n");
    }
```

> 注意: 必须强调的是,a[0],a[1],a[2]不能当作下标变量使用,它们是数组名,不是一个单纯的下标变量


### 二维数组的存储

- 和一维数组一样

* 给数组分配存储空间从内存地址大开始分配
* 给数组元素分配空间, 从所占用内存地址小的开始分配
* 往每个元素中存储数据从高地址开始存储

```c showLineNumbers
#include <stdio.h>
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    // cs == &cs == &cs[0] == &cs[0][0]
    printf("cs = %p\n", cs);                // 0060FEAA
    printf("&cs = %p\n", &cs);              // 0060FEAA
    printf("&cs[0] = %p\n", &cs[0]);        // 0060FEAA
    printf("&cs[0][0] = %p\n", &cs[0][0]);  // 0060FEAA
    return 0;
}
```

|二维数组变量名|内部一维数组|元素|地址|内容|
|---|---|---|---|---|
|cs|cs[1]|cs[1][2]|高|f|
|cs|cs[1]|cs[1][1]|...|e|
|cs|cs[1]|cs[1][0]|...|d|
|cs|cs[0]|cs[0][2]|...|c|
|cs|cs[0]|cs[0][1]|...|b|
|cs|cs[0]|cs[0][0]|低|a|


### 二维数组与函数

- 值传递

```c showLineNumbers
#include <stdio.h>

// 和一位数组一样, 只看形参是基本类型还是数组类型
// 如果是基本类型在函数中修改形参不会影响实参
void change(char ch){
    ch = 'n';
}
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("cs[0][0] = %c\n", cs[0][0]); // a
    change(cs[0][0]);
    printf("cs[0][0] = %c\n", cs[0][0]); // a
    return 0;
}
```

- 地址传递

```c showLineNumbers
#include <stdio.h>

// 和一位数组一样, 只看形参是基本类型还是数组类型
// 如果是数组类型在函数中修改形参会影响实参
void change(char ch[]){
    ch[0] = 'n';
}
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("cs[0][0] = %c\n", cs[0][0]); // a
    change(cs[0]);
    printf("cs[0][0] = %c\n", cs[0][0]); // n
    return 0;
}
```

```c showLineNumbers
#include <stdio.h>

// 和一位数组一样, 只看形参是基本类型还是数组类型
// 如果是数组类型在函数中修改形参会影响实参
void change(char ch[][3]){
    ch[0][0] = 'n';
}
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("cs[0][0] = %c\n", cs[0][0]); // a
    change(cs);
    printf("cs[0][0] = %c\n", cs[0][0]); // n
    return 0;
}
```

- 形参错误写法

```c showLineNumbers
void test(char cs[2][]) // 错误写法
{
    printf("我被执行了\n");
}

void test(char cs[2][3]) // 正确写法
{
    printf("我被执行了\n");
}

void test(char cs[][3]) // 正确写法
{
    printf("我被执行了\n");
}
```

- 二维数组作为函数参数，在被调函数中不能获得其有多少行，需要通过参数传入

```c showLineNumbers
void test(char cs[2][3])
{
    int row = sizeof(cs); // 输出4或8
    printf("row = %zu\n", row);
}
```

- 二维数组作为函数参数，在被调函数中可以计算出二维数组有多少列

```c showLineNumbers
void test(char cs[2][3])
{
    size_t col = sizeof(cs[0]); // 输出3
    printf("col = %zd\n", col);
}
```


## 指针基本概念

- 什么是地址

* 生活中的地址:
  ![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/9485373b7cb46f41f6c996303419ba4c.png)
* 内存地址:
  ![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/e46d975be9e95178136726209b2c237f.png)

- 地址与内存单元中的数据是两个完全不同的概念

* 地址如同房间编号, 根据这个编号我们可以找到对应的房间
* 内存单元如同房间, 房间是专门用于存储数据的

- 变量地址:

* 系统分配给"变量"的"内存单元"的起始地址

```c showLineNumbers
int num = 6; // 占用4个字节
//那么变量num的地址为: 0ff06

char c = 'a'; // 占用1个字节
//那么变量c的地址为:0ff05
```

![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/13eb965757dd130d813a953506335b89.png)

---

## 什么是指针

- 在计算机中所有数据都存储在内存单元中,而每个内存单元都有一个对应的地址, 只要通过这个地址就能找到对应单元中存储的数据.
- 由于通过地址能找到所需的变量单元，所以我们说该地址指向了该变量单元。将地址形象化的称为“指针”

- 内存单元的指针(地址)和内存单元的内容是两个不同的概念。
  ![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/540000371e0da0fb105248642ef9db24.png)

## 什么是指针变量

- 在 C 语言中,允许用一个变量来存放其它变量的地址, 这种专门用于存储其它变量地址的变量, 我们称之为指针变量
  ![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/02442ae9685e56146470369e56ca18ab.png)
- 示例:

```bash showLineNumbers
    int age;// 定义一个普通变量
    num = 10;
    int *pnAge; // 定义一个指针变量
    pnAge = &age;
```

![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/8b7b4d0976ad6e192e3ad6e26282fa8a.png)

## 定义指针变量的格式

- 指针变量的定义包括两个内容:

* 指针类型说明,即定义变量为一个指针变量;
* 指针变量名;
  ![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/c051703dcae8535c264ef47c20881b53.png)

- 示例:

```c showLineNumbers
char ch = 'a';
char *p; // 一个用于指向字符型变量的指针
p = &ch;
int num = 666;
int *q; // 一个用于指向整型变量的指针
q = &num;
```

> - 其中,\*表示这是一个指针变量
> - 变量名即为定义的指针变量名
> - 类型说明符表示本指针变量所指向的变量的数据类型

---

## 指针变量的初始化方法

- 指针变量初始化的方法有两种:定义的同时进行初始化和先定义后初始化

* 定义的同时进行初始化

```c showLineNumbers
int a = 5;
int *p = &a;
```

- 先定义后初始化

```c showLineNumbers
int a = 5;
int *p;
p=&a;
```

- 把指针初始化为 NULL

```c showLineNumbers
int *p=NULL;
int *q=0;
```

- 不合法的初始化:

* 指针变量只能存储地址, 不能存储其它类型

```c showLineNumbers
int *p;
p =  250; // 错误写法
```

- 给指针变量赋值时,指针变量前不能再加“\*”

```c showLineNumbers
int *p;
*p=&a; //错误写法
```

- 注意点:

* 多个指针变量可以指向同一个地址
  ![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/d4c9b29d8ddb808d1a12252fdcdf538a.png)

- 指针的指向是可以改变的

```c showLineNumbers
int a = 5;
int *p = &a;
int b = 10;
p = &b; // 修改指针指向
```

- 指针没有初始化里面是一个垃圾值,这时候我们这是一个野指针

* 野指针可能会导致程序崩溃
* 野指针访问你不该访问数据
* 所以指针必须初始化才可以访问其所指向存储区域
  ![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/e38cdad483acddca8cfcd85e7ac0be78.png)

## 访问指针所指向的存储空间

- C 语言中提供了地址运算符&来表示变量的地址。其一般形式为:

* &变量名;

- C 语言中提供了\*来定义指针变量和访问指针变量指向的内存存储空间

* 在定义变量的时候 \* 是一个类型说明符,说明定义的这个变量是一个指针变量

```c showLineNumbers
int *p=NULL; // 定义指针变量
```

- 在不是定义变量的时候 \*是一个操作符,代表访问指针所指向存储空间

```c showLineNumbers
int a = 5;
int *p = &a;
printf("a = %d", *p); // 访问指针变量
```

## 指针类型

- 在同一种编译器环境下,一个指针变量所占用的内存空间是固定的。
  ![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/a95f575889111ad8d64cc2c1aa8ecb1e.png)

- 虽然在同一种编译器下, 所有指针占用的内存空间是一样的,但不同类型的变量却占不同的字节数

* 一个 int 占用 4 个字节，一个 char 占用 1 个字节，而一个 double 占用 8 字节；
* 现在只有一个地址，我怎么才能知道要从这个地址开始向后访问多少个字节的存储空间呢，是 4 个，是 1 个，还是 8 个。
* 所以指针变量需要它所指向的数据类型告诉它要访问多少个字节存储空间
  ![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/af1fd05a523d9ba4e196e326f537589b.png)

---

## 二级指针

- 如果一个指针变量存放的又是另一个指针变量的地址,则称这个指针变量为指向指针的指针 ￼ 变量。也称为“二级指针”

```c showLineNumbers
    char c = 'a';
    char *cp;
    cp = &c;
    char **cp2;
    cp2 = &cp;
    printf("c = %c", **cp2);
```

![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/af331163ce03df7573810fc05ceb03c6.png)

- 多级指针的取值规则

```c showLineNumbers
int ***m1;  //取值***m1
int *****m2; //取值*****m2
```

---


## 数组指针的概念及定义

- 数组元素指针

* 一个变量有地址,一个数组包含若干元素,每个数组元素也有相应的地址, 指针变量也可以保存数组元素的地址
* 只要一个指针变量保存了数组元素的地址, 我们就称之为数组元素指针
  ![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/69b98c6401a04bf8fce52a78c80b9565.png)

```c showLineNumbers
    printf(“%p %p”, &(a[0]), a); //输出结果:0x1100, 0x1100
```

> - 注意: 数组名 a 不代表整个数组,只代表数组首元素的地址。
> - “p=a;”的作用是“把 a 数组的首元素的地址赋给指针变量 p”,而不是“把数组 a 各元素的值赋给 p”

##

## 指针访问数组元素

![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/13c0dd997ce619b1249220ce09610ad4.png)

```c showLineNumbers
    int main (void)
{
      int a[5] = {2, 4, 6, 8, 22};
      int *p;
      // p = &(a[0]);
      p = a;
      printf(“%d %d\n”,a[0],*p); // 输出结果: 2, 2
}

```

- 在指针指向数组元素时,允许以下运算:

* 加一个整数(用+或+=),如 p+1
* 减一个整数(用-或-=),如 p-1
* 自加运算,如 p++,++p
* 自减运算,如 p--,--p

![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/6c563fff4c62724055337604c2d31623.png)

> - 如果指针变量 p 已指向数组中的一个元素,则 p+1`指向`同一数组中的下一个元素,p-1`指向`同 一数组中的上一个元素。

- 结论: 访问数组元素,可用下面两种方法:

* 下标法, 如 a[i]形式
* 指针法, \*(p+i)形式

![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/e00312fbc775c04e2a449d7d8d473eb9.png)

- 注意:

* 数组名虽然是数组的首地址，但是数组名所所保存的数组的首地址是不可以更改的

```c showLineNumbers
  int x[10];
	x++;  //错误
	int* p = x;
	p++; //正确
```

##

## 指针与字符串

- 定义字符串的两种方式

* 字符数组

```c showLineNumbers
char string[]=”I love lnj!”;
printf("%s\n",string);
```

- 字符串指针指向字符串

```c showLineNumbers
// 数组名保存的是数组第0个元素的地址, 指针也可以保存第0个元素的地址
char *str = "abc"
```

![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/cb21fae540cb3290bbc41e7e223d3a41.png)

- 字符串指针使用注意事项

* 可以查看字符串的每一个字符

```c showLineNumbers
har *str = "lnj";
for(int i = 0; i < strlen(str);i++)
{
  printf("%c-", *(str+i)); // 输出结果:l-n-j
}
```

- - 不可以修改字符串内容

```c showLineNumbers
//   + 使用字符数组来保存的字符串是保存栈里的,保存栈里面东西是可读可写,所有可以修改字符串中的的字符
//   + 使用字符指针来保存字符串,它保存的是字符串常量地址,常量区是只读的,所以我们不可以修改字符串中的字符
char *str = "lnj";
*(str+2) = 'y'; // 错误
```

- - 不能够直接接收键盘输入

```c showLineNumbers
// 错误的原因是:str是一个野指针,他并没有指向某一块内存空间
// 所以不允许这样写如果给str分配内存空间是可以这样用 的
char *str;
scanf("%s", str);
```

## 指向函数指针

- 为什么指针可以指向一个函数？

* 函数作为一段程序，在内存中也要占据部分存储空间，它也有一个起始地址
* 函数有自己的地址，那就好办了，我们的指针变量就是用来存储地址的。
* 因此可以利用一个指针指向一个函数。其中，函数名就代表着函数的地址。

- 指针函数的定义

* 格式: `返回值类型 (*指针变量名)(形参1, 形参2, ...);`

```c showLineNumbers
    int sum(int a,int b)
    {
        return a + b;
    }

    int (*p)(int,int);
    p = sum;
```

- 指针函数定义技巧

* 1、把要指向函数头拷贝过来
* 2、把函数名称使用小括号括起来
* 3、在函数名称前面加上一个\*
* 4、修改函数名称

- 应用场景

* 调用函数
* 将函数作为参数在函数间传递

- 注意点:

* 由于这类指针变量存储的是一个函数的入口地址，所以对它们作加减运算(比如 p++)是无意义的
* 函数调用中"(指针变量名)"的两边的括号不可少,其中的不应该理解为求值运算,在此处它 只是一种表示符号

## 什么是结构体

- 结构体和数组一样属于构造类型
- 数组是用于保存一组相同类型数据的, 而结构体是用于保存一组不同类型数组的
- 例如,在学生登记表中,姓名应为字符型;学号可为整型或字符型;年龄应为整型;性别应为字符型;成绩可为整型或实型。
- 显然这组数据不能用数组来存放, 为了解决这个问题,C 语言中给出了另一种构造数据类型——“结构(structure)”或叫“结构体”。

---

## 定义结构体类型

- 在使用结构体之前必须先定义结构体类型, 因为 C 语言不知道你的结构体中需要存储哪些类型数据, 我们必须通过定义结构体类型来告诉 C 语言, 我们的结构体中需要存储哪些类型的数据
- 格式:

```c showLineNumbers
struct　结构体名{
     类型名1　成员名1;
     类型名2　成员名2;
     ……
     类型名n　成员名n;
 };
```

- 示例:

```c showLineNumbers
struct Student {
    char *name; // 姓名
    int age; // 年龄
    float height; // 身高
};
```

---

## 定义结构体变量

- 定好好结构体类型之后, 我们就可以利用我们定义的结构体类型来定义结构体变量
- 格式: `struct 结构体名 结构体变量名;`
  ![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/a19ef99bede1b3b0d689959881390bd0.png)

- 先定义结构体类型，再定义变量

```c showLineNumbers
struct Student {
     char *name;
     int age;
 };

 struct Student stu;
```

- 定义结构体类型的同时定义变量

```c showLineNumbers
struct Student {
    char *name;
    int age;
} stu;
```

- 匿名结构体定义结构体变量

```c showLineNumbers
struct {
    char *name;
    int age;
} stu;
```

> - 第三种方法与第二种方法的区别在于,第三种方法中省去了结构体类型名称,而直接给出结构变量,这种结构体最大的问题是结构体类型不能复用

---

## 结构体成员访问

- 一般对结构体变量的操作是以成员为单位进行的，引用的一般形式为：`结构体变量名.成员名`

```c showLineNumbers
struct Student {
     char *name;
     int age;
 };
 struct Student stu;
 // 访问stu的age成员
 stu.age = 27;
 printf("age = %d", stu.age);
```

---

## 结构体变量的初始化

- 定义的同时按顺序初始化

```c showLineNumbers
struct Student {
     char *name;
     int age;
 };
struct Student stu = {“lnj", 27};
```

- 定义的同时不按顺序初始化

```c showLineNumbers
struct Student {
     char *name;
     int age;
 };
struct Student stu = {.age = 35, .name = “lnj"};
```

- 先定义后逐个初始化

```c showLineNumbers
struct Student {
     char *name;
     int age;
 };
 struct Student stu;
stu.name = "lnj";
stu.age = 35;
```

- 先定义后一次性初始化

```c showLineNumbers
struct Student {
     char *name;
     int age;
 };
struct Student stu;
stu2 = (struct Student){"lnj", 35};
```

---

## 结构体类型作用域

- 结构类型定义在函数内部的作用域与局部变量的作用域是相同的

* 从定义的那一行开始, 直到遇到 return 或者大括号结束为止

- 结构类型定义在函数外部的作用域与全局变量的作用域是相同的

* 从定义的那一行开始,直到本文件结束为止

```c showLineNumbers
//定义一个全局结构体,作用域到文件末尾
struct Person{
    int age;
    char *name;
};

int main(int argc, const char * argv[])
{
    //定义局部结构体名为Person,会屏蔽全局结构体
    //局部结构体作用域,从定义开始到“}”块结束
    struct Person{
        int age;
    };
    // 使用局部结构体类型
    struct Person pp;
    pp.age = 50;
    pp.name = "zbz";

    test();
    return 0;
}

void test() {

    //使用全局的结构体定义结构体变量p
    struct Person p = {10,"sb"};
    printf("%d,%s\n",p.age,p.name);
}
```

## 结构体数组

- 结构体数组和普通数组并无太大差异, 只不过是数组中的元素都是结构体而已
- 格式: `struct 结构体类型名称 数组名称[元素个数]`

```c showLineNumbers
struct Student {
    char *name;
    int age;
};
struct Student stu[2];
```

- 结构体数组初始化和普通数组也一样, 分为先定义后初始化和定义同时初始化
  - 定义同时初始化

```c showLineNumbers
struct Student {
    char *name;
    int age;
};
struct Student stu[2] = {{"lnj", 35},{"zs", 18}};
```

- - 先定义后初始化

```c showLineNumbers
struct Student {
    char *name;
    int age;
};
struct Student stu[2];
stu[0] = {"lnj", 35};
stu[1] = {"zs", 18};
```

## 结构体指针

- 一个指针变量当用来指向一个结构体变量时,称之为结构体指针变量
- 格式: `struct 结构名 *结构指针变量名`
- 示例:

```c showLineNumbers
      // 定义一个结构体类型
      struct Student {
          char *name;
          int age;
      };

     // 定义一个结构体变量
     struct Student stu = {“lnj", 18};

     // 定义一个指向结构体的指针变量
     struct Student *p;

    // 指向结构体变量stu
    p = &stu;

     /*
      这时候可以用3种方式访问结构体的成员
      */
     // 方式1：结构体变量名.成员名
     printf("name=%s, age = %d \n", stu.name, stu.age);

     // 方式2：(*指针变量名).成员名
     printf("name=%s, age = %d \n", (*p).name, (*p).age);

     // 方式3：指针变量名->成员名
     printf("name=%s, age = %d \n", p->name, p->age);

     return 0;
 }
```

- 通过结构体指针访问结构体成员, 可以通过以下两种方式

* (\*结构指针变量).成员名
* 结构指针变量->成员名(用熟)

> - (pstu)两侧的括号不可少,因为成员符“.”的优先级高于“”。
> - 如去掉括号写作 pstu.num 则等效于(pstu.num),这样,意义就完全不对了。

## 结构体内存分析

- 给结构体变量开辟存储空间和给普通开辟存储空间一样, 会从内存地址大的位置开始开辟
- 给结构体成员开辟存储空间和给数组元素开辟存储空间一样, 会从所占用内存地址小的位置开始开辟
- 结构体变量占用的内存空间永远是所有成员中占用内存最大成员的倍数(对齐问题)

> +多实际的计算机系统对基本类型数据在内存中存放的位置有限制,它们会要求这些数据的起始地址的值是 某个数 k 的倍数,这就是所谓的内存对齐,而这个 k 则被称为该数据类型的对齐模数(alignment modulus)。
>
> - 这种强制的要求一来简化了处理器与内存之间传输系统的设计,二来可以提升读取数据的速度。比如这么一种处理器,它每次读写内存的时候都从某个 8 倍数的地址开始,一次读出或写入 8 个字节的数据,假如软件能 保证 double 类型的数据都从 8 倍数地址开始,那么读或写一个 double 类型数据就只需要一次内存操作。否则,我们就可能需要两次内存操作才能完成这个动作,因为数据或许恰好横跨在两个符合对齐要求的 8 字节 内存块上

## 结构体变量占用存储空间大小

```c showLineNumbers
    struct Person{
        int age; // 4
        char ch; // 1
        double score; // 8
    };
    struct Person p;
    printf("sizeof = %i\n", sizeof(p)); // 16
```

- 占用内存最大属性是 score, 占 8 个字节, 所以第一次会分配 8 个字节
- 将第一次分配的 8 个字节分配给 age4 个,分配给 ch1 个, 还剩下 3 个字节
- 当需要分配给 score 时, 发现只剩下 3 个字节, 所以会再次开辟 8 个字节存储空间
- 一共开辟了两次 8 个字节空间, 所以最终 p 占用 16 个字节

```c showLineNumbers
    struct Person{
        int age; // 4
        double score; // 8
        char ch; // 1
    };
    struct Person p;
    printf("sizeof = %i\n", sizeof(p)); // 24
```

- 占用内存最大属性是 score, 占 8 个字节, 所以第一次会分配 8 个字节
- 将第一次分配的 8 个字节分配给 age4 个,还剩下 4 个字节
- 当需要分配给 score 时, 发现只剩下 4 个字节, 所以会再次开辟 8 个字节存储空间
- 将新分配的 8 个字节分配给 score, 还剩下 0 个字节
- 当需要分配给 ch 时, 发现上一次分配的已经没有了, 所以会再次开辟 8 个字节存储空间
- 一共开辟了 3 次 8 个字节空间, 所以最终 p 占用 24 个字节

## 结构体嵌套定义

- 成员也可以又是一个结构,即构成了嵌套的结构

```c showLineNumbers
struct Date{
     int month;
     int day;
     int year;
}
struct  stu{
     int num;
    char *name;
    char sex;
    struct Date birthday;
    Float score;
}
```

- 在 stu 中嵌套存储 Date 结构体内容
  ![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/de4aedd768012888dc7b2e70a744c86d.png)

> - 注意:
> - 结构体不可以嵌套自己变量,可以嵌套指向自己这种类型的指针
>
> ```c showLineNumbers
> struct Student {
>  int age;
>  struct Student stu;
> };
> ```

- 对嵌套结构体成员的访问
  - 如果某个成员也是结构体变量，可以连续使用成员运算符"."访问最低一级成员

```c showLineNumbers
struct Date {
       int year;
       int month;
       int day;
  };

  struct Student {
      char *name;
      struct Date birthday;
 };

 struct Student stu;
 stu.birthday.year = 1986;
 stu.birthday.month = 9;
 stu.birthday.day = 10;
```

---

## 结构体和函数

- 结构体虽然是构造类型, 但是结构体之间赋值是值拷贝, 而不是地址传递

```c showLineNumbers
    struct Person{
        char *name;
        int age;
    };
    struct Person p1 = {"lnj", 35};
    struct Person p2;
    p2 = p1;
    p2.name = "zs"; // 修改p2不会影响p1
    printf("p1.name = %s\n", p1.name); // lnj
    printf("p2.name = %s\n", p2.name); //  zs
```

- 所以结构体变量作为函数形参时也是值传递, 在函数内修改形参, 不会影响外界实参

```c showLineNumbers
#include <stdio.h>

struct Person{
    char *name;
    int age;
};

void test(struct Person per);

int main()
{
    struct Person p1 = {"lnj", 35};
    printf("p1.name = %s\n", p1.name); // lnj
    test(p1);
    printf("p1.name = %s\n", p1.name); // lnj
    return 0;
}
void test(struct Person per){
    per.name = "zs";
}
```

## 共用体

- 和结构体不同的是, 结构体的每个成员都是占用一块独立的存储空间, 而共用体所有的成员都占用同一块存储空间
- 和结构体一样, 共用体在使用之前必须先定义共用体类型, 再定义共用体变量
- 定义共用体类型格式:

```c showLineNumbers
union 共用体名{
    数据类型 属性名称;
    数据类型 属性名称;
    ...   ....
};
```

- 定义共用体类型变量格式:

```c showLineNumbers
union 共用体名 共用体变量名称;
```

- 特点: 由于所有属性共享同一块内存空间, 所以只要其中一个属性发生了改变, 其它的属性都会受到影响
- 示例:

```c showLineNumbers
    union Test{
        int age;
        char ch;
    };
    union Test t;
    printf("sizeof(p) = %i\n", sizeof(t));

    t.age = 33;
    printf("t.age = %i\n", t.age); // 33
    t.ch = 'a';
    printf("t.ch = %c\n", t.ch); // a
    printf("t.age = %i\n", t.age); // 97
```

- 共用体的应用场景
  - （1）通信中的数据包会用到共用体，因为不知道对方会发送什么样的数据包过来，用共用体的话就简单了，定义几种格式的包，收到包之后就可以根据包的格式取出数据。
  - （2）节约内存。如果有 2 个很长的数据结构，但不会同时使用，比如一个表示老师，一个表示学生，要统计老师和学生的情况，用结构体就比较浪费内存，这时就可以考虑用共用体来设计。 +（3）某些应用需要大量的临时变量，这些变量类型不同，而且会随时更换。而你的堆栈空间有限，不能同时分配那么多临时变量。这时可以使用共用体让这些变量共享同一个内存空间，这些临时变量不用长期保存，用完即丢，和寄存器差不多，不用维护。


## 带参数的宏定义

- C 语言允许宏带有参数。在宏定义中的参数称为形式参数,在宏调用中的参数称为实际参数。对带参数的宏,在调用中,不仅要宏展开,而且要用实参去代换形参
- 格式: `#define 宏名(形参表) 字符串`

```c showLineNumbers
// 第1行中定义了一个带有2个参数的宏average，
#define average(a, b) (a+b)/2

int main ()
  {
  // 第4行其实会被替换成：int a = (10 + 4)/2;，
    int a = average(10, 4);
  // 输出结果为：7
  // 是不是感觉这个宏有点像函数呢？
    printf("平均值：%d", a);
    return 0;
 }
```

- **注意点:**
- 1)宏名和参数列表之间不能有空格，否则空格后面的所有字符串都作为替换的字符串.

```c showLineNumbers
#define average (a, b) (a+b)/2

 int main ()
 {
     int a = average(10, 4);
     return 0;
 }
注意第1行的宏定义，宏名average跟(a, b)之间是有空格的，于是，第5行就变成了这样：
int a = (a, b) (a+b)/2(10, 4);
这个肯定是编译不通过的
```

- 2)带参数的宏在展开时，只作简单的字符和参数的替换，不进行任何计算操作。所以在定义宏时，一般用一个小括号括住字符串的参数。

```c showLineNumbers
#include <stdio.h>
  // 下面定义一个宏D(a)，作用是返回a的2倍数值：
  #define D(a) 2*a
  // 如果定义宏的时候不用小括号括住参数

  int main ()
  {
  // 将被替换成int b = 2*3+4;，输出结果10，如果定义宏的时候用小括号括住参数，把上面的第3行改成：#define D(a) 2*(a)，注意右边的a是有括号的，第7行将被替换成int b = 2*(3+4);，输出结果14

     int b = D(3+4);
     printf("%d", b);
     return 0;
 }
```

- 3)计算结果最好也用括号括起来

```c showLineNumbers
#include <stdio.h>
// 下面定义一个宏P(a)，作用是返回a的平方
#define Pow(a) (a) * (a) // 如果不用小括号括住计算结果

int main(int argc, const char * argv[])      {
// 代码被替换为:int b = (10) * (10) / (2) * (2);
// 简化之后：int b = 10 * (10 / 2) * 2;，最后变量b为:100
      int b = Pow(10) / Pow(2);

      printf("%d", b);
      return 0;
}
```

```c showLineNumbers
#include <stdio.h>
// 计算结果用括号括起来
#define Pow(a) ( (a) * (a) )

int main(int argc, const char * argv[])      {
// 代码被替换为:int b = ( (10) * (10) ) / ( (2) * (2) );
// 简化之后：int b = (10 * 10) / (2 *2);，最后输出结果：25
      int b = Pow(10) / Pow(2);

      printf("%d", b);
      return 0;
}
```

## typedef 关键字

- C 语言不仅 􏰀 供了丰富的数据类型,而且还允许由用户自己定义类型说明符,也就是说允许由用户为数据类型取“别名”。
- 格式: `typedef 原类型名 新类型名;`

* 其中原类型名中含有定义部分,新类型名一般用大写表示,以便于区别。
* 有时也可用宏定义来代替 typedef 的功能,但是宏定义是由预处理完成的,而 typedef 则是在编译 时完成的,后者更为灵活方便。
  ##typedef 使用

- 基本数据类型

```c showLineNumbers
typedef int INTEGER
INTEGER a; // 等价于 int a;
```

- 也可以在别名的基础上再起一个别名

```c showLineNumbers
typedef int Integer;

typedef Integer MyInteger;

```

- 用 typedef 定义数组、指针、结构等类型将带来很大的方便,不仅使程序书写简单而且使意义更为 明确,因而增强了可读性。

- 数组类型

```c showLineNumbers
typedef char NAME[20]; // 表示NAME是字符数组类型,数组长度为20。然后可用NAME 说明变量,
NAME a; // 等价于 char a[20];
```

- 结构体类型

* 第一种形式:

```c showLineNumbers
 struct Person{
    int age;
    char *name;
};

typedef struct Person PersonType;
```

    + 第二种形式:

```c showLineNumbers
typedef struct Person{
    int age;
    char *name;
} PersonType;
```

    + 第三种形式:

```c showLineNumbers
typedef struct {
    int age;
    char *name;
} PersonType;
```

- 枚举

* 第一种形式:

```c showLineNumbers
enum Sex{
    SexMan,
    SexWoman,
    SexOther
};
typedef enum Sex SexType;
```

    + 第二种形式:

```c showLineNumbers
typedef enum Sex{
    SexMan,
    SexWoman,
    SexOther
} SexType;
```

    + 第三种形式:

```c showLineNumbers
typedef enum{
    SexMan,
    SexWoman,
    SexOther
} SexType;
```

- 指针

* typedef 与指向结构体的指针

```c showLineNumbers
 // 定义一个结构体并起别名
  typedef struct {
      float x;
      float y;
  } Point;

 // 起别名
 typedef Point *PP;

```

- typedef 与指向函数的指针

```c showLineNumbers
// 定义一个sum函数，计算a跟b的和
  int sum(int a, int b) {
      int c = a + b;
      printf("%d + %d = %d", a, b, c);
      return c;
 }
 typedef int (*MySum)(int, int);

// 定义一个指向sum函数的指针变量p
 MySum p = sum;
```

## 宏定义与函数以及 typedef 区别

- 与函数的区别

* 从整个使用过程可以发现，带参数的宏定义，在源程序中出现的形式与函数很像。但是两者是有本质区别的：
* 1> 宏定义不涉及存储空间的分配、参数类型匹配、参数传递、返回值问题
* 2> 函数调用在程序运行时执行，而宏替换只在编译预处理阶段进行。所以带参数的宏比函数具有更高的执行效率

- typedef 和#define 的区别

* 用宏定义表示数据类型和用 typedef 定义数据说明符的区别。
* 宏定义只是简单的字符串替换,￼ 是在预处理完成的
* typedef 是在编译时处理的,它不是作简单的代换,而是对类型说明符 ￼ 重新命名。被命名的标识符具有类型定义说明的功能

```c showLineNumbers
typedef char *String;
int main(int argc, const char * argv[])
{
     String str = "This is a string!";
     return 0;
}


#define String char *
int main(int argc, const char * argv[])
{
    String str = "This is a string!";
     return 0;
}
```

```c showLineNumbers
typedef char *String1; // 给char *起了个别名String1
#define String2 char * // 定义了宏String2
int main(int argc, const char * argv[]) {
        /*
        只有str1、str2、str3才是指向char类型的指针变量
        由于String1就是char *，所以上面的两行代码等于:
        char *str1;
        char *str2;
        */
      String1 str1, str2;
        /*
        宏定义只是简单替换, 所以相当于
        char *str3, str4;
        *号只对最近的一个有效, 所以相当于
        char *str3;
        char str4;
        */
      String2 str3, str4;
      return 0;
}
```

