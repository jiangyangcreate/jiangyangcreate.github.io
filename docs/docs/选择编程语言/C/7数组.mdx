---
sidebar_position: 7
title: 数组
---


## 数组的基本概念

- 数组，从字面上看，就是一组数据的意思，没错，数组就是用来存储一组数据的
  - 在 C 语言中,数组属于**构造数据类型**
- 数组的几个名词
  - 数组:一组`相同数据类型`数据的`有序`的集合
  - 数组元素: 构成数组的每一个数据。
  - 数组的下标: 数组元素位置的索引(从 0 开始)
- 数组的应用场景
  - 一个 int 类型的变量能保存一个人的年龄，如果想保存整个班的年龄呢？
    - 第一种方法是定义很多个 int 类型的变量来存储
    - 第二种方法是只需要定义一个 int 类型的数组来存储

```c showLineNumbers
#include <stdio.h>

int main(int argc, const char * argv[]) {
    /*
    // 需求: 保存2个人的分数
    int score1 = 99;
    int score2 = 60;

    // 需求: 保存全班同学的分数(130人)
    int score3 = 78;
    int score4 = 68;
    ...
    int score130 = 88;
    */
    // 数组: 如果需要保存`一组``相同类型`的数据, 就可以定义一个数组来保存
    // 只要定义好一个数组, 数组内部会给每一块小的存储空间一个编号, 这个编号我们称之为 索引, 索引从0开始
    // 1.定义一个可以保存3个int类型的数组
    int scores[3];

    // 2.通过数组的下标往数组中存放数据
    scores[0] = 998;
    scores[1] = 123;
    scores[2] = 567;

    // 3.通过数组的下标从数组中取出存放的数据
    printf("%i\n", scores[0]);
    printf("%i\n", scores[1]);
    printf("%i\n", scores[2]);
    return 0;
}
```

---

## 定义数组

- 元素类型 数组名[元素个数];

```c showLineNumbers
// int 元素类型
// ages 数组名称
// [10] 元素个数
int ages[10];
```

---

## 初始化数组

- **定义的同时初始化**
- 指定元素个数,完全初始化
  - 其中在{ }中的各数据值即为各元素的初值,各值之间用逗号间隔

```c showLineNumbers
int ages[3] = {4, 6, 9};
```

- 不指定元素个数,完全初始化
  - 根据大括号中的元素的个数来确定数组的元素个数

```c showLineNumbers
int nums[] = {1,2,3,5,6};
```

- 指定元素个数,部分初始化
  - 没有显式初始化的元素,那么系统会自动将其初始化为 0

```c showLineNumbers
int nums[10] = {1,2};
```

- 指定元素个数,部分初始化

```c showLineNumbers
int nums[5] = {[4] = 3,[1] = 2};
```

- 不指定元素个数,部分初始化

```c showLineNumbers
int nums[] = {[4] = 3};
```

- **先定义后初始化**

```c showLineNumbers
int nums[3];
nums[0] = 1;
nums[1] = 2;
nums[2] = 3;
```

- 没有初始化会怎样?
  - 如果定义数组后,没有初始化,数组中是有值的,是随机的垃圾数,所以如果想要正确使用数组应该要进行初始化。

```c showLineNumbers
int nums[5];
printf("%d\n", nums[0]);
printf("%d\n", nums[1]);
printf("%d\n", nums[2]);
printf("%d\n", nums[3]);
printf("%d\n", nums[4]);
输出结果:
0
0
1606416312
0
1606416414
```

- 注意点:

- 使用数组时不能超出数组的索引范围使用, 索引从 0 开始, 到元素个数-1 结束
- 使用数组时不要随意使用未初始化的元素, 有可能是一个随机值
- 对于数组来说, 只能在定义的同时初始化多个值, 不能先定义再初始化多个值

```c showLineNumbers
int ages[3];
ages = {4, 6, 9}; // 报错
```

---

## 数组的使用

- 通过下标（索引）访问：

```c showLineNumbers
// 找到下标为0的元素, 赋值为10
ages[0]=10;
// 取出下标为2的元素保存的值
int a = ages[2];
printf("a = %d", a);
```

---

## 数组的遍历

- 数组的遍历:遍历的意思就是有序地查看数组的每一个元素

```c showLineNumbers
    int ages[4] = {19, 22, 33, 13};
    for (int i = 0; i < 4; i++) {
        printf("ages[%d] = %d\n", i, ages[i]);
    }
```

---

## 数组长度计算方法

- 因为数组在内存中占用的字节数取决于其存储的数据类型和数据的个数
  - 数组所占用存储空间 = 一个元素所占用存储空间 \* 元素个数(数组长度)
- 所以计算数组长度可以使用如下方法
  数组的长度 = 数组占用的总字节数 / 数组元素占用的字节数

```c showLineNumbers
    int ages[4] = {19, 22, 33, 13};
    int length =  sizeof(ages)/sizeof(int);
    printf("length = %d", length);
输出结果: 4
```

---

## 练习

- 正序输出(遍历)数组

```c showLineNumbers
    int ages[4] = {19, 22, 33, 13};
    for (int i = 0; i < 4; i++) {
        printf("ages[%d] = %d\n", i, ages[i]);
    }
```

- 逆序输出(遍历)数组

```c showLineNumbers
    int ages[4] = {19, 22, 33, 13};
    for (int i = 3; i >=0; i--) {
        printf("ages[%d] = %d\n", i, ages[i]);
    }
```

- 从键盘输入数组长度,构建一个数组,然后再通过 for 循环从键 盘接收数字给数组初始化。并使用 for 循环输出查看


## 数组内部存储细节

- 存储方式:

* 1)内存寻址从大到小, 从高地址开辟一块连续没有被使用的内存给数组
* 2)从分配的连续存储空间中, 地址小的位置开始给每个元素分配空间
* 3)从每个元素分配的存储空间中, 地址最大的位置开始存储数据
* 4)用数组名指向整个存储空间最小的地址

- 示例

```c showLineNumbers
#include <stdio.h>
int main()
{
    int num = 9;
    char cs[] = {'l','n','j'};
    printf("cs = %p\n", &cs);       // cs = 0060FEA9
    printf("cs[0] = %p\n", &cs[0]); // cs[0] = 0060FEA9
    printf("cs[1] = %p\n", &cs[1]); // cs[1] = 0060FEAA
    printf("cs[2] = %p\n", &cs[2]); // cs[2] = 0060FEAB

    int nums[] = {2, 6};
    printf("nums = %p\n", &nums);      // nums = 0060FEA0
    printf("nums[0] = %p\n", &nums[0]);// nums[0] = 0060FEA0
    printf("nums[1] = %p\n", &nums[1]);// nums[1] = 0060FEA4

    return 0;
}
```

![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/e0aa63f597f92632c90cd1c5f6adc292.png)

> - 注意:字符在内存中是以对应 ASCII 码值的二进制形式存储的,而非上述的形式。

## 数组的越界问题

- 数组越界导致的问题

* 约错对象
* 程序崩溃

```c showLineNumbers
    char cs1[2] = {1, 2};
    char cs2[3] = {3, 4, 5};
    cs2[3] = 88; // 注意:这句访问到了不属于cs1的内存
    printf("cs1[0] = %d\n", cs1[0] );
    输出结果: 88
```

> 为什么上述会输出 88, 自己按照"数组内部存储细节"画图脑补

---

## 数组注意事项

- 在定义数组的时候[]里面只能写整型常量或者是返回整型常量的表达式

```c showLineNumbers
 int ages4['A'] = {19, 22, 33};
 printf("ages4[0] = %d\n", ages4[0]);

  int ages5[5 + 5] = {19, 22, 33};
  printf("ages5[0] = %d\n", ages5[0]);

  int ages5['A' + 5] = {19, 22, 33};
  printf("ages5[0] = %d\n", ages5[0]);
```

- 错误写法

```c showLineNumbers
// 没有指定元素个数，错误
int a[];

// []中不能放变量
int number = 10;
int ages[number]; // 老版本的C语言规范不支持
printf("%d\n", ages[4]);

int number = 10;
int ages2[number] = {19, 22, 33} // 直接报错

// 只能在定义数组的时候进行一次性（全部赋值）的初始化
int ages3[5];
ages10 = {19, 22, 33};

// 一个长度为n的数组,最大下标为n-1, 下标范围:0~n-1
int ages4[4] = {19, 22, 33}
ages4[8]; // 数组角标越界
```

- 练习

* 从键盘录入当天出售 BTC 的价格并计算出售的 BTC 的总价和平均价(比如说一天出售了 10 个比特币)

## 数组和函数

- 数组可以作为函数的参数使用,数组用作函数参数有两种形式:
  - ￼ 一种是把数组元素作为实参使用
  - ￼ 一种是把数组名作为函数的形参和实参使用

---

## 数组元素作为函数参数

- 数组的元素作为函数实参，与同类型的简单变量作为实参一样，如果是基本数据类型, 那么形参的改变不影响实参

```c showLineNumbers
void change(int val)// int val = number
{
    val = 55;
}
int main(int argc, const char * argv[])
{
    int ages[3] = {1, 5, 8};
    printf("ages[0] = %d", ages[0]);// 1
    change(ages[0]);
    printf("ages[0] = %d", ages[0]);// 1
}
```

> - 用数组元素作函数参数不要求形参也必须是数组元素

---

## 数组名作为函数参数

- 在 C 语言中,数组名除作为变量的标识符之外,数组名还代表了该数组在内存中的起始地址,因此,当数组名作函数参数时,实参与形参之间不是"值传递",而是"地址传递"
- 实参数组名将该数组的起始地址传递给形参数组,两个数组共享一段内存单元, 系统不再为形参数组分配存储单元
- 既然两个数组共享一段内存单元, 所以形参数组修改时，实参数组也同时被修改了

```c showLineNumbers
void change2(int array[3])// int array = 0ffd1
{
    array[0] = 88;
}
int main(int argc, const char * argv[])
{
    int ages[3] = {1, 5, 8};
    printf("ages[0] = %d", ages[0]);// 1
    change(ages);
    printf("ages[0] = %d", ages[0]);// 88
}
```

---

## 数组名作函数参数的注意点

- 在函数形参表中,允许不给出形参数组的长度

```c showLineNumbers
void change(int array[])
{
    array[0] = 88;
}
```

- 形参数组和实参数组的类型必须一致,否则将引起错误。

```c showLineNumbers
void prtArray(double array[3]) // 错误写法
{
    for (int i = 0; i < 3; i++) {
        printf("array[%d], %f", i, array[i]);
    }
}
int main(int argc, const char * argv[])
{
    int ages[3] = {1, 5, 8};
    prtArray(ages[0]);
}
```

- 当数组名作为函数参数时, 因为自动转换为了指针类型，所以在函数中无法动态计算除数组的元素个数

```c showLineNumbers
void printArray(int array[])
{
    printf("printArray size = %lu\n", sizeof(array)); // 8
    int length = sizeof(array)/ sizeof(int); // 2
    printf("length = %d", length);
}
```

- 练习:
  - 设计一个函数 int arrayMax(int a[], int count)找出数组元素的最大值
  - 从键盘输入 3 个 0-9 的数字,然后输出 0~9 中哪些数字没有出现过
  - 要求从键盘输入 6 个 0~9 的数字,排序后输出




## 二维数组

- 所谓二维数组就是一个一维数组的每个元素又被声明为一 维数组,从而构成二维数组. 可以说二维数组是特殊的一维数组。
- 示例:

```c showLineNumbers
int a[2][3] = { {80,75,92}, {61,65,71}};
```

- 可以看作由一维数组 a[0]和一维数组 a[1]组成，这两个一维数组都包含了 3 个 int 类型的元素
  ![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/c716d53c6b228ea211a524645a5d13a5.png)

## 二维数组的定义

- 格式:

* 数据类型 数组名[一维数组的个数][一维数组的元素个数]
* 其中"一维数组的个数"表示当前二维数组中包含多少个一维数组
* 其中"一维数组的元素个数"表示当前前二维数组中每个一维数组元素的个数

---

## 二维数组的初始化

- 二维数的初始化可分为两种:

* 定义的同时初始化
* 先定义后初始化

- 定义的同时初始化

```c showLineNumbers
int a[2][3]={ {80,75,92}, {61,65,71}};
```

- 先定义后初始化

```c showLineNumbers
int a[2][3];
a[0][0] = 80;
a[0][1] = 75;
a[0][2] = 92;
a[1][0] = 61;
a[1][1] = 65;
a[1][2] = 71;
```

- 按行分段赋值

```c showLineNumbers
int a[2][3]={ {80,75,92}, {61,65,71}};
```

- 按行连续赋值

```c showLineNumbers
int a[2][3]={ 80,75,92,61,65,71};
```

- 其它写法

* 完全初始化,可以省略第一维的长度

```c showLineNumbers
int a[][3]={{1,2,3},{4,5,6}};int a[][3]={1,2,3,4,5,6};
```

- 部分初始化,可以省略第一维的长度

```c showLineNumbers
int a[][3]={{1},{4,5}};int a[][3]={1,2,3,4};
```

> - 注意: 有些人可能想不明白，为什么可以省略行数，但不可以省略列数。也有人可能会问，可不可以只指定行数，但是省略列数？其实这个问题很简单，如果我们这样写：
>   `int a[2][] = {1, 2, 3, 4, 5, 6};  // 错误写法`
>   大家都知道，二维数组会先存放第 1 行的元素，由于不确定列数，也就是不确定第 1 行要存放多少个元素，所以这里会产生很多种情况，可能 1、2 是属于第 1 行的，也可能 1、2、3、4 是第一行的，甚至 1、2、3、4、5、6 全部都是属于第 1 行的

- 指定元素的初始化

```c showLineNumbers
int a[2][3]={[1][2]=10};int a[2][3]={[1]={1,2,3}}
```

## 二维数组的应用场景

![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/f351a6ed231c8a1a5e6379da6816fd1c.png)
![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/dd8a18bdb49031d24c98bc311e80ab78.png)
![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/dee64b6cb0f5c043402880d0062d2393.png)

## 二维数组的遍历和存储

## 二维数组的遍历

- 二维数组 a[3][4],可分解为三个一维数组,其数组名分别为:

* 这三个一维数组都有 4 个元素,例如:一维数组 a[0]的 元素为 a[0][0],a[0][1],a[0][2],a[0][3]。
* 所以遍历二维数组无非就是先取出二维数组中得一维数组, 然后再从一维数组中取出每个元素的值

- 示例

```c showLineNumbers
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("%c", cs[0][0]);// 第一个[0]取出一维数组, 第二个[0]取出一维数组中对应的元素
```

```c showLineNumbers
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    for (int i = 0; i < 2; i++) { // 外循环取出一维数组
        // i
        for (int j = 0; j < 3; j++) {// 内循环取出一维数组的每个元素
            printf("%c", cs[i][j]);
        }
        printf("\n");
    }
```

> 注意: 必须强调的是,a[0],a[1],a[2]不能当作下标变量使用,它们是数组名,不是一个单纯的下标变量

---

## 二维数组的存储

- 和以为数组一样

* 给数组分配存储空间从内存地址大开始分配
* 给数组元素分配空间, 从所占用内存地址小的开始分配
* 往每个元素中存储数据从高地址开始存储

```c showLineNumbers
#include <stdio.h>
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    // cs == &cs == &cs[0] == &cs[0][0]
    printf("cs = %p\n", cs);                // 0060FEAA
    printf("&cs = %p\n", &cs);              // 0060FEAA
    printf("&cs[0] = %p\n", &cs[0]);        // 0060FEAA
    printf("&cs[0][0] = %p\n", &cs[0][0]);  // 0060FEAA
    return 0;
}
```

![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/b3da2217fbaf93e346a390a47cad9a50.png)

## 二维数组与函数

- 值传递

```c showLineNumbers
#include <stdio.h>

// 和一位数组一样, 只看形参是基本类型还是数组类型
// 如果是基本类型在函数中修改形参不会影响实参
void change(char ch){
    ch = 'n';
}
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("cs[0][0] = %c\n", cs[0][0]); // a
    change(cs[0][0]);
    printf("cs[0][0] = %c\n", cs[0][0]); // a
    return 0;
}
```

- 地址传递

```c showLineNumbers
#include <stdio.h>

// 和一位数组一样, 只看形参是基本类型还是数组类型
// 如果是数组类型在函数中修改形参会影响实参
void change(char ch[]){
    ch[0] = 'n';
}
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("cs[0][0] = %c\n", cs[0][0]); // a
    change(cs[0]);
    printf("cs[0][0] = %c\n", cs[0][0]); // n
    return 0;
}
```

```c showLineNumbers
#include <stdio.h>

// 和一位数组一样, 只看形参是基本类型还是数组类型
// 如果是数组类型在函数中修改形参会影响实参
void change(char ch[][3]){
    ch[0][0] = 'n';
}
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("cs[0][0] = %c\n", cs[0][0]); // a
    change(cs);
    printf("cs[0][0] = %c\n", cs[0][0]); // n
    return 0;
}
```

- 形参错误写法

```c showLineNumbers
void test(char cs[2][]) // 错误写法
{
    printf("我被执行了\n");
}

void test(char cs[2][3]) // 正确写法
{
    printf("我被执行了\n");
}

void test(char cs[][3]) // 正确写法
{
    printf("我被执行了\n");
}
```

- 二维数组作为函数参数，在被调函数中不能获得其有多少行，需要通过参数传入

```c showLineNumbers
void test(char cs[2][3])
{
    int row = sizeof(cs); // 输出4或8
    printf("row = %zu\n", row);
}
```

- 二维数组作为函数参数，在被调函数中可以计算出二维数组有多少列

```c showLineNumbers
void test(char cs[2][3])
{
    size_t col = sizeof(cs[0]); // 输出3
    printf("col = %zd\n", col);
}
```

## 作业

- 玩家通过键盘录入 w,s,a,d 控制小人向不同方向移动,其中 w 代表向上移动,s 代表向 下移动,a 代表向左移动,d 代表向右移动,当小人移动到出口位置,玩家胜利

- 思路:
- 1.定义二维数组存放地图

```c showLineNumbers
     ######
     #O #
     # ## #
     #  # #
     ##   #
     ######
```

- 2.规定地图的方向
  ![](https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/img_convert/7331a7700b09543cef73fa0bbddc3c16.png)
- 3.编写程序控制方向

* 当输入 w 或者 W, 小人向上移动. x-1
* 当输入 s 或者 S, 小人向下. x+1
* 当输入 a 或者 A, 小人向左. y-1
* 当输入 d 或者 D, 小人向右. y+1

- 4.移动小人

* 用变量记录小人当前的位置
  - 1)如果小人将要移动的位置是墙,则无法移动
  - 2)如果小人将要移动的位置是路,则可以移动

- 5.判断是否走出迷宫
