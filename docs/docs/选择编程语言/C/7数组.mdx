---
sidebar_position: 7
title: （编写中）构造数据
---

构造数据是指由用户可以定义的、非内置的数据类型。主要有数组、结构体、联合体。


## 数组

数组属于**构造数据类型**，是一组`相同类型`数据的`连续内存`集合。

数组的特点包括：

- 固定大小（编译时确定）
- 元素类型相同
- 内存连续分配
- 通过下标访问（从0开始）

前面提到的基本的数据类型又可以和数组结合，形成新的构造数据类型。这里不再逐一列举。

定义数组:`数据类型 数组名[数组长度];`

```c showLineNumbers
// int 元素类型
// ages 数组名称
// [10] 数组长度 即 元素个数
int ages[10];
// 数组名为ages, 数组类型为int [10]

int scores[5];     // 5个整数的数组
double temps[30];    // 30个双精度浮点数
char name[20];     // 20个字符的字符数组，也叫字符串
```


### 初始化数组

```c showLineNumbers
// 完全初始化, 其中在{ }中的各数据值即为各元素的初值,各值之间用逗号间隔
// 定义的同时可以初始化多个值
int ages[3] = {4, 6, 9};

// 完全初始化,不指定元素个数,自动计算长度
int days[] = {31,28,31,30,31};  // 自动确定为5个元素

// 部分初始化（剩余自动补0）
int arr[5] = {1, 2};     // [1, 2, 0, 0, 0]

// 部分初始化,指定位置的元素初始化
int nums[5] = {[0] = 1,[1] = 2}; // [1, 2, 0, 0, 0]


// 先定义后初始化
int nums[3];

nums[0] = 1;
nums[1] = 2;
nums[2] = 3;

int ages[3]; // 定义后只能逐个初始化值
ages = {4, 6, 9}; // 报错
```

如果定义数组后,<Highlight>没有初始化,数组中是随机的垃圾数</Highlight>,所以如果想要正确使用数组应该要进行初始化。


:::info

在定义数组的时候[]里面能写整型常量或者是返回整型常量的表达式

不能写变量。

```c showLineNumbers
#include <stdio.h>

int main() {
    int ages1['A'] = {19, 22, 33};// 'A' 会被转换为 65
    printf("ages1[0] = %d\n", ages1[0]);

    int ages2[5 + 5] = {19, 22, 33};
    printf("ages2[0] = %d\n", ages2[0]);

    int ages3['A' + 5] = {19, 22, 33};// 'A' + 5会被转换为 70
    printf("ages3[0] = %d\n", ages3[0]);

    printf("sizeof(ages3) = %lu\n", sizeof(ages3));// 大小为 70 * 4 = 280
}

```
:::

### 数组元素的访问

使用数组时不能超出数组的索引范围使用, 索引从 0 开始, 到元素个数-1 结束

通过下标（索引）访问：

```c showLineNumbers
int nums[3] = {10, 20, 30};
nums[0] = 15;       // 修改第一个元素
int x = nums[2];     // 读取第三个元素

// 越界访问
int arr[3];
arr[5] = 10;  // 未定义行为！可能破坏其他内存，导致程序崩溃
```

### 数组的遍历

遍历的意思就是有序地查看数组的每一个元素

```c showLineNumbers
#include <stdio.h>
int main() {
    
    int ages[4] = {11, 22, 33, 44};

    // 正序输出(遍历)数组
    for (int i = 0; i < 4; i++) {
        printf("ages[%d] = %d\n", i, ages[i]);
    }

    // 逆序输出(遍历)数组
    for (int i = 3; i >=0; i--) {
        printf("ages[%d] = %d\n", i, ages[i]);
    }

    return 0;
    }
```


### 数组的内存

因为数组在内存中占用的字节数取决于其存储的数据类型和数据的个数

数组所占用存储空间 = 一个元素所占用存储空间 x 元素个数(数组长度)

可以使用`sizeof`函数来计算数组所占用的存储总空间和元素所占用的空间，进一步可以计算出数组的长度

```c showLineNumbers
#include <stdio.h>
int main() {
    int ages[4] = {19, 22, 33};
    int length = sizeof(ages) / sizeof(ages[0]);
    printf("length = %d\n", length); 
    return 0;
}

```

- 内存寻址从大到小, **系统**从高地址开辟一块连续没有被使用的（栈）内存给数组
- 从分配的连续存储空间中, 地址小的位置开始给每个元素分配空间
- 数组名指向整个存储空间最小的地址

```c showLineNumbers
#include <stdio.h>
int main()
{
    char cs[] = {'l','n','j'}; // 获得三个高地址。假设为：99、98、97
    // 数组名指向整个存储空间最小的地址
    printf("cs = %p\n", &cs);       // cs = 97
    // 数组元素指向每个元素的地址
    // 从分配的连续存储空间中, 地址小的位置开始给每个元素分配空间
    printf("cs[0] = %p\n", &cs[0]); // cs[0] = 97
    printf("cs[1] = %p\n", &cs[1]); // cs[1] = 98
    printf("cs[2] = %p\n", &cs[2]); // cs[2] = 99
    return 0;
}
```

:::info
系统自动分配的内存空间叫做栈。从高地址开始，依次向下分配。默认 1-8 MB。可调整到几十MB，但不宜太大,因为每个线程都需要独立堆区(不用也占着)，多线程会占用大量内存。

那么我们程序员则可以从下往上使用内存，叫做堆。使用堆时，系统不会自动分配内存，需要我们自己申请。（不超过系统实际可用内存大小）堆是共享的,实际用多少分配多少（不用别人可以用）。

使用堆的情况：需要大量内存/不知道需要多大内存/需要跨函数使用

栈和堆是同一块物理内存的不同逻辑区域，可以调整栈和堆的大小比例。

```
堆 = 公共仓库
  - 所有线程（工人）共享
  - 需要登记（加锁）才能拿东西
  - 容量大，但可能需要排队

栈 = 个人工具箱
  - 每个线程（工人）有自己的
  - 不需要跟别人抢
  - 空间小，但访问快
```

| 特性 | 栈（Stack） | 堆（Heap） |
|------|------------|-----------|
| **共享性** | 每线程独立 | 所有线程共享 |
| **空间分配** | 创建线程时预留 | 按需动态增长 |
| **多线程开销** | 线程数 × 栈大小 | 所有线程共用一个 |
| **线程安全** | 天然线程安全 | 需要同步机制 |
| **访问速度** | 快（无竞争） | 较慢（可能竞争） |
| **适用场景** | 临时变量、函数调用 | 共享数据、大对象 |
:::

### 数组和函数

数组可以作为函数的参数使用,数组用作函数参数有两种形式:
- 一种是把数组元素作为实参使用
- 一种是把数组名作为函数的形参和实参使用


- 数组的元素作为函数实参，与同类型的简单变量作为实参一样，如果是基本数据类型, 那么形参的改变不影响实参

```c showLineNumbers
void change(int val)// int val = number
{
    val = 55;
}
int main(int argc, const char * argv[])
{
    int ages[3] = {1, 5, 8};
    printf("ages[0] = %d", ages[0]);// 1
    change(ages[0]);
    printf("ages[0] = %d", ages[0]);// 1
}
```

> - 用数组元素作函数参数不要求形参也必须是数组元素



### 数组名作为函数参数

- 在 C 语言中,数组名除作为变量的标识符之外,数组名还代表了该数组在内存中的起始地址,因此,当数组名作函数参数时,实参与形参之间不是"值传递",而是"地址传递"
- 实参数组名将该数组的起始地址传递给形参数组,两个数组共享一段内存单元, 系统不再为形参数组分配存储单元
- 既然两个数组共享一段内存单元, 所以形参数组修改时，实参数组也同时被修改了

```c showLineNumbers
void change2(int array[3])// int array = 0ffd1
{
    array[0] = 88;
}
int main(int argc, const char * argv[])
{
    int ages[3] = {1, 5, 8};
    printf("ages[0] = %d", ages[0]);// 1
    change(ages);
    printf("ages[0] = %d", ages[0]);// 88
}
```


### 数组名作函数参数的注意点

- 在函数形参表中,允许不给出形参数组的长度

```c showLineNumbers
void change(int array[])
{
    array[0] = 88;
}
```

- 形参数组和实参数组的类型必须一致,否则将引起错误。

```c showLineNumbers
void prtArray(double array[3]) // 错误写法
{
    for (int i = 0; i < 3; i++) {
        printf("array[%d], %f", i, array[i]);
    }
}
int main(int argc, const char * argv[])
{
    int ages[3] = {1, 5, 8};
    prtArray(ages[0]);
}
```

- 当数组名作为函数参数时, 因为自动转换为了指针类型，所以在函数中无法动态计算除数组的元素个数

```c showLineNumbers
void printArray(int array[])
{
    printf("printArray size = %lu\n", sizeof(array)); // 8
    int length = sizeof(array)/ sizeof(int); // 2
    printf("length = %d", length);
}
```


### 二维数组

- 所谓二维数组就是一个一维数组的每个元素又被声明为一 维数组,从而构成二维数组. 可以说二维数组是特殊的一维数组。
- 示例:

```c showLineNumbers
int a[2][3] = { {80,75,92}, {61,65,71}};
```

- 格式:

* 数据类型 数组名[一维数组的个数][一维数组的元素个数]
* 其中"一维数组的个数"表示当前二维数组中包含多少个一维数组
* 其中"一维数组的元素个数"表示当前前二维数组中每个一维数组元素的个数


### 二维数组的初始化

- 二维数的初始化可分为两种:

* 定义的同时初始化
* 先定义后初始化

- 定义的同时初始化

```c showLineNumbers
int a[2][3]={ {80,75,92}, {61,65,71}};
```

- 先定义后初始化

```c showLineNumbers
int a[2][3];
a[0][0] = 80;
a[0][1] = 75;
a[0][2] = 92;
a[1][0] = 61;
a[1][1] = 65;
a[1][2] = 71;
```

- 按行分段赋值

```c showLineNumbers
int a[2][3]={ {80,75,92}, {61,65,71}};
```

- 按行连续赋值

```c showLineNumbers
int a[2][3]={ 80,75,92,61,65,71};
```

- 其它写法

* 完全初始化,可以省略第一维的长度

```c showLineNumbers
int a[][3]={{1,2,3},{4,5,6}};int a[][3]={1,2,3,4,5,6};
```

- 部分初始化,可以省略第一维的长度

```c showLineNumbers
int a[][3]={{1},{4,5}};int a[][3]={1,2,3,4};
```

> - 注意: 有些人可能想不明白，为什么可以省略行数，但不可以省略列数。也有人可能会问，可不可以只指定行数，但是省略列数？其实这个问题很简单，如果我们这样写：
>   `int a[2][] = {1, 2, 3, 4, 5, 6};  // 错误写法`
>   大家都知道，二维数组会先存放第 1 行的元素，由于不确定列数，也就是不确定第 1 行要存放多少个元素，所以这里会产生很多种情况，可能 1、2 是属于第 1 行的，也可能 1、2、3、4 是第一行的，甚至 1、2、3、4、5、6 全部都是属于第 1 行的

- 指定元素的初始化

```c showLineNumbers
int a[2][3]={[1][2]=10};int a[2][3]={[1]={1,2,3}}
```

### 二维数组的应用场景

象棋、围棋的棋子的表示。网格地图的数据表示。

### 二维数组的遍历和存储

### 二维数组的遍历

- 二维数组 a[3][4],可分解为三个一维数组,其数组名分别为:

* 这三个一维数组都有 4 个元素,例如:一维数组 a[0]的 元素为 a[0][0],a[0][1],a[0][2],a[0][3]。
* 所以遍历二维数组无非就是先取出二维数组中得一维数组, 然后再从一维数组中取出每个元素的值

- 示例

```c showLineNumbers
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("%c", cs[0][0]);// 第一个[0]取出一维数组, 第二个[0]取出一维数组中对应的元素
```

```c showLineNumbers
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    for (int i = 0; i < 2; i++) { // 外循环取出一维数组
        // i
        for (int j = 0; j < 3; j++) {// 内循环取出一维数组的每个元素
            printf("%c", cs[i][j]);
        }
        printf("\n");
    }
```

> 注意: 必须强调的是,a[0],a[1],a[2]不能当作下标变量使用,它们是数组名,不是一个单纯的下标变量


### 二维数组的存储

- 和一维数组一样

* 给数组分配存储空间从内存地址大开始分配
* 给数组元素分配空间, 从所占用内存地址小的开始分配
* 往每个元素中存储数据从高地址开始存储

```c showLineNumbers
#include <stdio.h>
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    // cs == &cs == &cs[0] == &cs[0][0]
    printf("cs = %p\n", cs);                // 0060FEAA
    printf("&cs = %p\n", &cs);              // 0060FEAA
    printf("&cs[0] = %p\n", &cs[0]);        // 0060FEAA
    printf("&cs[0][0] = %p\n", &cs[0][0]);  // 0060FEAA
    return 0;
}
```

|二维数组变量名|内部一维数组|元素|地址|内容|
|---|---|---|---|---|
|cs|cs[1]|cs[1][2]|高|f|
|cs|cs[1]|cs[1][1]|...|e|
|cs|cs[1]|cs[1][0]|...|d|
|cs|cs[0]|cs[0][2]|...|c|
|cs|cs[0]|cs[0][1]|...|b|
|cs|cs[0]|cs[0][0]|低|a|


### 二维数组与函数

- 值传递

```c showLineNumbers
#include <stdio.h>

// 和一位数组一样, 只看形参是基本类型还是数组类型
// 如果是基本类型在函数中修改形参不会影响实参
void change(char ch){
    ch = 'n';
}
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("cs[0][0] = %c\n", cs[0][0]); // a
    change(cs[0][0]);
    printf("cs[0][0] = %c\n", cs[0][0]); // a
    return 0;
}
```

- 地址传递

```c showLineNumbers
#include <stdio.h>

// 和一位数组一样, 只看形参是基本类型还是数组类型
// 如果是数组类型在函数中修改形参会影响实参
void change(char ch[]){
    ch[0] = 'n';
}
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("cs[0][0] = %c\n", cs[0][0]); // a
    change(cs[0]);
    printf("cs[0][0] = %c\n", cs[0][0]); // n
    return 0;
}
```

```c showLineNumbers
#include <stdio.h>

// 和一位数组一样, 只看形参是基本类型还是数组类型
// 如果是数组类型在函数中修改形参会影响实参
void change(char ch[][3]){
    ch[0][0] = 'n';
}
int main()
{
    char cs[2][3] = {
        {'a', 'b', 'c'},
        {'d', 'e', 'f'}
    };
    printf("cs[0][0] = %c\n", cs[0][0]); // a
    change(cs);
    printf("cs[0][0] = %c\n", cs[0][0]); // n
    return 0;
}
```

- 形参错误写法

```c showLineNumbers
void test(char cs[2][]) // 错误写法
{
    printf("我被执行了\n");
}

void test(char cs[2][3]) // 正确写法
{
    printf("我被执行了\n");
}

void test(char cs[][3]) // 正确写法
{
    printf("我被执行了\n");
}
```

- 二维数组作为函数参数，在被调函数中不能获得其有多少行，需要通过参数传入

```c showLineNumbers
void test(char cs[2][3])
{
    int row = sizeof(cs); // 输出4或8
    printf("row = %zu\n", row);
}
```

- 二维数组作为函数参数，在被调函数中可以计算出二维数组有多少列

```c showLineNumbers
void test(char cs[2][3])
{
    size_t col = sizeof(cs[0]); // 输出3
    printf("col = %zd\n", col);
}
```
