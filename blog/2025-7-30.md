---
title: ROS2视觉运动算法仿真
date: 2025-7-30
authors: jiangmiemie
tags: [ROS2,视觉,运动算法,仿真]
keywords: [ROS2,视觉运动算法,Gazebo,rclpy,机器人仿真] 
description: 通过ROS2官方提供的Gazebo虚拟仿真，实现视觉运动算法仿真  
---

本章节通过ROS2官方提供的Gazebo虚拟仿真，实现视觉运动算法仿真。

:::info
什么是视觉运动控制算法？

运动控制算法主要是通过传感器，将采集到的数据，转化为运动控制指令。

传感器包含：视觉、重力、力反馈、加速度、测距等多种类型。特斯拉的自动驾驶使用的方案中视觉是最主要的信息来源。

运动控制从易到难有：履带结构、差速结构、阿克曼结构、全向结构、足腿结构。
:::

:::info

为什么要虚拟仿真？

目前较为先进的腿足结构机器人想要完成高难度动作，例如：后空翻、前空翻、韦伯斯特空翻。一旦失败会对本不充裕的原型机造成严重的损坏。

所以通过仿真软件训练，有如下好处：

- 可以在低风险的情况下完成算法的调试和优化。
- 对于复杂算法，可以同时启动多个仿真软件，进行并行训练，提高训练效率。
:::


:::warning
虚拟仿真需要一定的算力。本地使用前，首先确保你的电脑包含显卡。

- 高算力的电脑可以使用wsl安装Ubuntu。

- ❌使用VM虚拟机会产生较大的延迟。

- ✔普通电脑可以使用原生Ubuntu最大限度发挥硬件性能。

- ❌非原生环境下可能出现消息异常、时间异常等问题。
:::

## ROS2框架

ROS 2需要依赖于Ubuntu系统，其微控制器相较于普通MCU成本更高。主要用于高级机器人。

### 通信优势

#### 丰富的通信类型

ROS 2节省自己搭建网络、定义通信类型、管理连接的时间。

| 通信模式 | 作用 | 特点 | 应用场景 |
| :--- | :--- | :--- | :--- |
| **话题：发布-订阅 (Publish-Subscribe)** | 单向、异步数据流 | 高效、解耦，适用于传感器数据流、状态更新 | 传感器数据流（如相机图像、激光雷达数据）、机器人状态更新（如位置、速度） |
| **服务：服务端-客户端 (Service-Client)** | 同步、请求-响应 | 阻塞式通信，用于需要明确结果的任务 | 触发特定动作（如抓取物体）、查询物体 ID |
| **动作 (Actions)** | 长时任务处理 | 异步、支持进度反馈和取消 | 移动机器人到指定位置、机械臂执行复杂任务 |
| **参数 (Parameters)** | 动态配置节点行为 | 非实时通信，用于启动时或运行时的配置调整 | 调整 PID 控制器增益、修改传感器发布频率 |


#### 自动发现机制

同为ROS 2，在同一网段下的不同设备可以<Highlight>自动发现</Highlight>。

:::info
自动发现前提：指要求中继设备允许子设备自由通信。

中继设备可能是路由器、或者手机的热点、随身WIFI等。

允许子设备自由通信有利有弊，如果你在商场或者咖啡馆连接他们的WIFI，你的电脑可能提醒你：你的网络活动可能被其他设备发现。自由通信会带来一定的安全隐患。因此并不是所有的路由器都默认允许允许子设备自由通信。

有的设备会有防火墙，临时关闭防火墙：`sudo ufw disable`，另外要允许`UDP`多播端口（默认7400~7500）。
:::

如果一切正常，你应该可以通过`ping <其他机器的IP>`并联通成功。

此时你可以通过`ros2`运行节点发布消息，其他设备的接收者会收到你的消息。

#### 隔离机制

如果你同个网段下，有无人机和机器狗。你想将其编队为：空军 + 陆军；又或者5台无人机 + 机器狗为一组。

ROS 2提供了通信<Highlight>隔离机制</Highlight>。

在同个编队的所有设备终端中执行：`export ROS_DOMAIN_ID=1`。（值范围为0~101，0为默认值）

这个命令是设置了一个环境变量。ROS 2通过判断这个环境变量来识别是否为一组。不同ID节点无法通信。

因此如果你想将其分为两组，只需要在一半的设备上改为非0的，相同的ID即可。

#### 多设备跨域通信

如果你的设备分别在两个城市，可以通过配置一台公网下的服务器(也可以在两个网段下，配置一个都能访问的设备作为中继)，将两个城市的设备连接到这台服务器上。这种通信方式被称为<Highlight>Fast-DDS</Highlight>。

在服务器上运行：`fastdds discovery --server-id 0`。

服务器开放11888端口。`sudo ufw allow 11888/tcp`

在设备上运行：`export ROS_DISCOVERY_SERVERS=<服务器IP>:<服务器端口>`。（端口默认11888）

设置ROS中间件为`rmw_fastrtps_cpp`(别人写好的包)：`export RMW_IMPLEMENTATION=rmw_fastrtps_cpp`
然后重新监听：`ros2 daemon stop`，再重新启动：`ros2 daemon start`。

### 模块仓库

ROS 2有大量写好的机器人相关的包，包也称：模块、功能包、库。

安装相机标定：
`sudo apt install ros-jazzy-camera-calibration`

安装SLAM：
`sudo apt install ros-jazzy-slam-toolbox`

你会发现你只需要安装一个包，就可以获得一个功能。和Python通过pip安装包一样。安装后即可实现"一行代码"实现某个功能。

### ROS 2安装

安装过程中注意：ROS 2的版本往往与ubuntu的版本有关。查看[https://docs.ros.org/](https://docs.ros.org/)可获得目前主流的版本。

#### 设置编码

```bash
sudo apt update && sudo apt install locales
sudo locale-gen en_US en_US.UTF-8
sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 
export LANG=en_US.UTF-8
```

#### 添加源

```bash
sudo apt update && sudo apt install curl gnupg lsb-release 
sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg 
echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os-release && echo $UBUNTU_CODENAME) main" | sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null
```

#### 安装ROS 2

```bash
sudo apt update

sudo apt upgrade

# 如果你是ubuntu 24.04，那么安装jazzy版本
sudo apt install ros-jazzy-desktop
```

#### 设置环境变量

```bash
# 立刻执行脚本
source /opt/ros/jazzy/setup.bash

# 之后每次开启终端执行执行脚本
echo " source /opt/ros/jazzy/setup.bash" >> ~/.bashrc 
```

你也可以使用Docker简化这个过程。


复杂的功能需要很多依赖，系统中默认的Python3出于安全考虑，可能不让你在全局环境中安装包。代码的提示给了很多选项，例如安装在虚拟环境中，删除安全文件。加上关键字，<Highlight>你应该学会通过翻译软件，翻译报错信息。它让你看某个文件，也请学会使用翻译软件，翻译文件内容。</Highlight>

```bash
error: externally-managed-environment

× This environment is externally managed
╰─> To install Python packages system-wide, try apt install
    python3-xyz, where xyz is the package you are trying to
    install.
    
    If you wish to install a non-Debian-packaged Python package,
    create a virtual environment using python3 -m venv path/to/venv.
    Then use path/to/venv/bin/python and path/to/venv/bin/pip. Make
    sure you have python3-full installed.
    
    If you wish to install a non-Debian packaged Python application,
    it may be easiest to use pipx install xyz, which will manage a
    virtual environment for you. Make sure you have pipx installed.
    
    See /usr/share/doc/python3.12/README.venv for more information.

note: If you believe this is a mistake, please contact your Python installation or OS distribution provider. You can override this, at the risk of breaking your Python installation or OS, by passing --break-system-packages.
hint: See PEP 668 for the detailed specification.
```

根据提示，得到的解决方式之一：`pip3 install 你的包 --break-system-packages`

或者可以把`externally managed`文件删除。

```bash
sudo apt install -y python3-pip

sudo pip3 install rosdepc --break-system-packages

sudo rosdepc init

rosdepc update
```


### 节点基操

节点是通信的基本单位，节点可以变成：发布者、订阅者、服务端、客户端、动作、参数。

#### 创建节点

创建节点前可以先创建一个目录

```bash
mkdir -p ~/workspace/src
```

如何在ROS2中创建一个功能包呢？我们可以使用这个指令：
```bash
ros2 pkg create --build-type <build-type> <package_name>
```
ros2命令中：

- pkg：表示功能包相关的功能；
- create：表示创建功能包；
- build-type：表示新创建的功能包是C++还是Python的，如果使用C++或者C，那这里就跟ament_cmake，如果使用Python，就跟ament_python；
- package_name：新建功能包的名字。

```bash
# 创建Python功能包
ros2 pkg create --build-type ament_python learning_node

# 创建C++功能包
ros2 pkg create --build-type ament_cmake learning_node
```
<Highlight>只需执行其中一个命令即可，如果你会Python，就执行创建Python节点的命令。</Highlight>命令创建一个名为`learning_node`文件夹。

这里我推荐大家创建节点名的时候，使用有辨识性的名字。例如：`ros2 pkg create --build-type ament_python learning_node`。

:::info
注意：对于节点同名，ROS 2在编译时的处理方式不是使用第一个节点或最后一个节点，而是会报错。
:::

#### 编写代码

接着在`learning_node`文件夹我们就可以准备编写代码了，此时你的路径应该是：

```bash
~/workspace
    |_src
        |_learning_node/
            |_learning_node
                |_ __init__.py
            |_package.xml
            |_setup.py
            |_setup.cfg
            |_test/
            |_resource/
```

此时你就可以编写代码了,在`__init__.py`<Highlight>同级</Highlight>下创建一个`.py`文件。

符合文件命名规则前提下，你想叫什么都可以，但是最好有一定的含义。

如果你的功能是打印`Hello World`，那么你就可以叫`node_helloworld.py`。

python的函数通常是需要调用的，例如`abc()`函数，你需要在代码中输入`abc()`，才会调用这个函数。和C++有且仅有一个`main`函数不同，那么如何确定哪个函数是入口？更进一步思考：不同的指令对应不同的函数。


因此有了`setup.py`最下方的入口点定义。编写完成后记得修改`setup.py`最下方的入口点。

详细内容参可以参考现成的仓库：

:::info
拉取git仓库，可免去自己从0开始手敲代码。如果你喜欢自己从0开始抄写代码，也可以跳过本部分。

git安装：`sudo apt install git`

拉取命令：`git clone https://gitee.com/guyuehome/ros2_21_tutorials.git`

这个命令会把仓库克隆到本地。执行后，你应该能在<Highlight>当前文件夹下</Highlight>看到名为`ros2_21_tutorials`的文件夹，内含多个子文件夹。每个子文件夹对应一个功能包。因为ros2是<Highlight>模块化的</Highlight>，不同的功能被拆解为不同的功能包后期更好维护。
:::

注意：如果你之前在`src`里创建了一些Python节点之后，又把`ros2_21_tutorials`文件夹也放置在`src`里，那么你需要检查你的创建的节点名，是否与`ros2_21_tutorials`内已有节点重名。

#### 编译

```bash
# 安装colcon（此步全局仅在第一次执行时需要执行，如果失败会导致colcon build 命令不可用）
sudo apt install python3-colcon-ros

# 进入工作空间
cd ~/workspace

# 编译工作空间所有功能包
# 不论其是直接在src下，还是在src下的子文件夹下
colcon build

# 当你只有一个包更改，不希望全编译，仅编译learning_node
colcon build --packages-select learning_node
```

`colcon build`命令会将所有功能包，编译成可执行文件。

编译成功后，就可以在工作空间中看到自动生产的build、log、install文件夹了。

- src，代码空间，未来编写的代码、脚本，都需要人为的放置到这里；
- build，编译空间，保存编译过程中产生的中间文件；
- install，安装空间，放置编译得到的可执行文件和脚本；
- log，日志空间，编译和运行过程中，保存各种警告、错误、信息等日志。

我们把编译后，含有`build、log、install、src`文件夹的`workspace`称为<Highlight>工作空间</Highlight>。

如果是Python这样无需编译的，会将代码直接拷贝到`install`文件夹下。

编译过程可能出现的报错：

- 节点重名：对与节点同名，ros的处理方式不是使用第一个节点或最后一个节点，而是会报错。应该删除多余节点。确保你`src`文件夹下，所有的`xml`文件中，节点的名称是唯一的。

- 语法错误：如果代码语法错误，则会编译失败，需要手动解决。

- 缺少依赖包：如果你严格跟随参考资料且为新系统，首先检查你是否安装过程网络异常。如果是曾用系统，检查是否含有多个python环境。
```bash
# 删除缓存
rm -rf build/ install/ log/

# 修改环境变量PATH的值，把系统默认的环境提到最前
export PATH="/usr/bin:$PATH"

# PYTHON_EXECUTABLE 是一个CMake变量，用于指定构建过程中应该使用哪个Python解释器
export PYTHON_EXECUTABLE=/usr/bin/python3 && colcon build --cmake-args -DPYTHON_EXECUTABLE=/usr/bin/python3
```

<Highlight>在不更换工作空间的情况下，以下命令仅在第一次执行时需要执行。</Highlight>如果你的工作空间路径不是`~/workspace`，请将`~/workspace`替换为你的工作空间路径。

```bash
# 立刻执行脚本
source ~/workspace/install/setup.sh

# 之后每次开启终端执行执行脚本
echo "source ~/workspace/install/setup.sh" >> ~/.bashrc
```

#### 运行

运行脚本 : `ros2 run learning_node node_helloworld`

查看<Highlight>正在运行</Highlight>的node : `ros2 node list`

### rclpy

rclpy模块，ROS 2  Python标准接口 （ROS 2 canonical API with Python）

官网：https://docs.ros.org/en/rolling/p/rclpy/index.html

受限于篇幅，只简单介绍其中初始化部分

#### 入门体验

下面是一个标准的初始化代码`init`支持传入多种参数。

```python
import rclpy                                     # ROS2 Python接口库
from rclpy.node import Node                      # ROS2 节点类
import time

def main(args=None):                             # ROS2节点主入口main函数
    rclpy.init(args=args)                        # ROS2 Python接口初始化
    node = Node("node_helloworld")               # 创建ROS2节点对象并进行初始化
    
    while rclpy.ok():                            # ROS2系统是否正常运行
        node.get_logger().info("Hello World")    # ROS2日志输出
        time.sleep(0.5)                          # 休眠控制循环时间
    node.destroy_node()                          # 销毁节点对象   
    rclpy.shutdown()                             # 关闭ROS2 Python接口
```

##### 初始化

`rclpy.init(*, args: List[str] | None = None, context: Context | None = None, domain_id: int | None = None, signal_handler_options: rpyutils.import_c_library.SignalHandlerOptions | None = None)→ InitContextManager`

直接初始化比上下文初始化拥有更多的参数。

Parameters:

- args – 命令行参数列表。
- context – 要初始化的上下文。如果为 None，则使用默认上下文。
- domain_id – ROS 域 ID。
- signal_handler_options – 指示要安装的信号处理程序。如果 None，则在初始化默认上下文时将安装 SIGINT 和 SIGTERM。【类似于 Python 的信号（signal）机制，是操作系统发出的异步事件。而非异常，异常是程序内部发生的同步事件。】

Returns:

- 一个 InitContextManager，可以与 Python 上下文管理器一起使用进行清理。

##### 循环执行

ROS 2 中的 Executor（执行器）是用来管理和运行 ROS 2 节点中所有回调函数的核心组件。你可以把它看作是一个调度器，它决定了节点里的各种任务（例如接收新消息、处理服务请求、定时器触发）何时执行。

Executor 负责调度和执行节点中的回调函数。一个 ROS 2 节点可以有多个回调函数，比如：

- 订阅者的回调函数：每当收到一个新消息时被调用。

- 服务的请求回调函数：每当收到一个服务请求时被调用。

- 定时器的回调函数：每隔一定时间被调用。

节点本身并不会自动运行这些回调函数，它需要一个 Executor 来 "spin"（自旋），也就是不断地检查是否有就绪的任务并执行它们。ROS 2 将节点和执行器分开，提供了灵活性。你可以选择不同的 Executor 来适应你的应用需求：

- SingleThreadedExecutor：这是最简单的执行器，它在一个单独的线程里顺序执行所有就绪的回调函数。

- MultiThreadedExecutor：这个执行器使用一个线程池，可以同时执行多个回调函数，这对于需要高并发处理的节点非常有用。


`rclpy.spin(node: Node, executor: Executor | None = None)→ None`:执行工作，直到与执行器关联的上下文关闭。

- node – 要添加到执行器以检查工作的节点。
- 要使用的执行器，如果是 None，则为全局执行器。

`rclpy.spin_once(node: Node, *, executor: Executor | None = None, timeout_sec: float | None = None)→ None`:执行一项工作或等待超时到期。

只要该回调在超时到期之前准备就绪，提供的执行器就会执行一个回调。如果未提供执行器（即 None），则使用全局执行器。如果全局执行器具有部分完成的协程，则完成的工作可能是针对提供的节点以外的节点。

- node – 要添加到执行器以检查工作的节点。
- executor – 要使用的执行器，如果是 None，则为全局执行器。
- timeout_sec – 等待几秒钟。如果为 “无” 或“负数，则永久阻止”。如果为 0，请不要等待。


`rclpy.spin_until_future_complete(node: Node, future: Future[Any], executor: Executor | None = None, timeout_sec: float | None = None)→ None` : 执行工作，直到Future完成。

- node – 要添加到执行器以检查工作的节点。
- 要等待的 future 对象。直到 future.done（） 返回 True 或与执行器关联的上下文为 shutdown。
- 要使用的执行器，如果是 None，则为全局执行器。
- 等待几秒钟。如果为 None 或负数，则阻止直到未来完成。如果为 0，请不要等待。

##### 关闭

`rclpy.shutdown(*, context: Context | None = None, uninstall_handlers: bool | None = None)→ None`

关闭以前初始化的上下文（如果尚未关闭）。这也将关闭全局执行器，如果已关闭会报错。

- context – 要失效的上下文。如果为 None，则使用默认上下文
- uninstall_handlers – 如果为 None，则在关闭默认上下文时将卸载信号处理程序。如果为 True，则将卸载信号处理程序。如果为 False，则不会卸载信号处理程序。和前面signal_handler_options对应上。

`rclpy.try_shutdown(*, context: Context | None = None, uninstall_handlers: bool | None = None)→ None`

关闭以前初始化的上下文（如果尚未关闭）。这也将关闭全局执行器，如果已关闭不会报错。

- context – 要失效的上下文。如果为 None，则使用默认上下文
- uninstall_handlers – 如果为 None，则在关闭默认上下文时将卸载信号处理程序。如果为 True，则将卸载信号处理程序。如果为 False，则不会卸载信号处理程序。和前面signal_handler_options对应上。


#### 上下文


上下文管理器Context与直接使用rclpy基本一致，但背后其实是线程管理，每个独立的上下文管理器都是独立的线程。

如果使用`rclpy.init(args=args)`则无法完成创建2个不同的domian_id的节点。

```python
from rclpy.node import Node                      # ROS2 节点类
from rclpy.context import Context                # ROS2 上下文类
import time

def main(args=None):                             # ROS2节点主入口main函数
    # 使用Context上下文管理器的正确方式
    context = Context()
    context.init(args,domain_id=1)
    node = Node("node_helloworld", context=context)  # 创建节点并关联上下文

    context2 = Context()
    context2.init(args,domain_id=2)
    node2 = Node("node_helloworld", context=context2)  # 创建节点并关联上下文

    while context.ok() and context2.ok():                  # 检查上下文是否正常
        node.get_logger().info("{}".format(context.get_domain_id()))    # ROS2日志输出
        node2.get_logger().info("{}".format(context2.get_domain_id()))    # ROS2日志输出
        time.sleep(0.5)                  # 休眠控制循环时间
    context2.shutdown()
    context.shutdown()
```

使用上下文管理器Context 的`with`语法可以自动`init`（不支持参数），并在with语句结束时调用`shutdown`，代码更加简洁。

类似于Python的 `with open`与`close`。

```python
from rclpy.node import Node                      # ROS2 节点类
from rclpy.context import Context                # ROS2 上下文类
import time

def main(args=None):                             # ROS2节点主入口main函数
    # 使用Context上下文管理器的正确方式
    with Context() as context:
        node = Node("node_helloworld", context=context)  # 创建节点并关联上下文
        while context.ok():                  # 检查上下文是否正常
            # 输出当前的domain id ，默认是0
            # 修改domain id方式1 ：修改当前终端变量
            # export ROS_DOMAIN_ID=1
            node.get_logger().info("{}".format(context.get_domain_id())) 
            time.sleep(0.5)                  # 休眠控制循环时间
```
##### 初始化

`context.init(args: List[str] | None = None, *, initialize_logging: bool = True, domain_id: int | None = None)→ None`

为给定上下文初始化 ROS 通信。

- args – 命令行参数列表。
- initialize_logging – 是否初始化整个过程的日志记录。默认值是初始化日志记录。
- domain_id – 要用于此上下文的域 ID。如果为无（默认值），则使用域 ID 0。

##### 状态检察

`context.get_domain_id()→ int`：获取上下文的domain ID。

`context.ok()→ bool`：检查上下文是否未关闭。

##### 跟踪

`track_node(node: Node)→ None`:跟踪与此上下文关联的节点。当上下文被销毁时，它将销毁它跟踪的每个节点。

`untrack_node(node: Node)→ None`:如果一个节点在上下文之前被销毁，我们不再需要跟踪它是否销毁了上下文，所以在此处将其删除。

##### 关闭上下文

`context.shutdown()→ None`：关闭此上下文，会等待正在进行的操作完成，然后清理资源。好比执行系统关机，如果已关闭会报错。

`on_shutdown(callback: Callable[[], None])→ None`：添加关机时调用的回调。

`try_shutdown()→ None`:尝试关闭此上下文（如果尚未关闭）,如果已关闭也不会报错。

`context.destroy()→ None`：销毁上下文，立即释放资源，不等待正在进行的操作。好比直接断电。

### 通信示例

[ROS2的基础通信](#通信优势)类型的示例代码都在[ros2_21_tutorials](https://gitee.com/guyuehome/ros2_21_tutorials)仓库中。拉取到`src`文件夹中，参考上文编译、运行即可。

#### 话题

- 运行话题的发布者节点 ： `ros2 run learning_topic topic_helloworld_pub`
- 运行话题的订阅者节点 ： `ros2 run learning_topic topic_helloworld_sub`

可以看到发布者循环发布“Hello World”字符串消息，订阅者也以几乎同样的频率收到该话题的消息数据。

#### 服务

- 运行服务的服务端节点 ： `ros2 run learning_service service_adder_server`
- 运行服务的客户端节点 ： `ros2 run learning_service service_adder_client 2 3`

#### 动作

- 运行动作的服务端节点 ： `ros2 run learning_action action_move_server `
- 运行动作的客户端节点 ： `ros2 run learning_action action_move_client`


#### 参数

等价于机器学习中的`超参数`即：在开始训练前设置的参数，例如：学习率、隐藏层大小、迭代次数等等。

<Highlight>ROS机器人系统中的参数是全局字典，可以运行多个节点中共享数据。</Highlight>

- 运行节点 ：`ros2 run learning_parameter param_declare`
- 在另外终端设置参数 ：`ros2 param set param_declare robot_name turtle`


## Gazebo

Gazebo是一款开源的3D仿真软件，用于模拟机器人在复杂环境中的行为。它提供了丰富的物理引擎和传感器模型，可以模拟机器人的运动、碰撞、传感器数据等。

```bash
# 安装gz
sudo apt-get install ros-jazzy-ros-gz

# 测试（参数 empty.sdf 表示空场景）
# 测试能否正常启动且无卡顿，gz_args:=empty.sdf表示使用空场景
ros2 launch ros_gz_sim gz_sim.launch.py gz_args:=empty.sdf
```

[gazebosim](https://app.gazebosim.org/fuel/models)有大量下载好的模型(models)与场景(worlds)可以使用。

想简单点就选一个自带摄像头的机器人模型，如果有中意的机器人模型没摄像头的，可以自己加一个摄像头。

场景选赛道类的，有明显的车道线，可以较好的测试算法。如果场景过于简单可以适当的添加一些模型，例如：路灯、树木、箱子等。

### URDF

URDF（Unified Robot Description Format）是一种用于描述机器人模型的XML格式。

一个带摄像头的机器人模型示例：

```xml showLineNumbers title="my_robot.sdf"
<?xml version="1.0" ?>
<sdf version="1.11">
  <world name="default">
    <!-- 系统插件 - 必须启用才能让传感器工作 -->
    <plugin filename="gz-sim-sensors-system" name="gz::sim::systems::Sensors">
      <render_engine>ogre2</render_engine>
    </plugin>
    <plugin filename="gz-sim-user-commands-system" name="gz::sim::systems::UserCommands"/>
    <plugin filename="gz-sim-scene-broadcaster-system" name="gz::sim::systems::SceneBroadcaster"/>

    <!-- 物理引擎 -->
    <physics name="default_physics" type="ode">
      <max_step_size>0.001</max_step_size>
      <real_time_factor>1.0</real_time_factor>
    </physics>

    <!-- 地面 -->
    <model name="ground_plane">
      <static>true</static>
      <link name="link">
        <collision name="collision">
          <geometry>
            <plane><normal>0 0 1</normal><size>100 100</size></plane>
          </geometry>
        </collision>
        <visual name="visual">
          <geometry>
            <plane><normal>0 0 1</normal><size>100 100</size></plane>
          </geometry>
          <material>
            <ambient>0.8 0.8 0.8 1</ambient>
            <diffuse>0.8 0.8 0.8 1</diffuse>
          </material>
        </visual>
      </link>
    </model>

    <!-- 车道线 -->
    <model name="lane_line">
      <static>true</static>
      <link name="line">
        <visual name="lane_visual">
          <pose>0 0 0.0001 0 0 0</pose>
          <geometry>
            <box><size>10.0 0.1 0.001</size></box>
          </geometry>
          <material>
            <ambient>1 1 1 1</ambient>
            <diffuse>1 1 1 1</diffuse>
          </material>
        </visual>
      </link>
    </model>

    <!-- 四轮机器人 -->
    <model name="my_robot">
      <pose>0 0 0.1 0 0 0</pose>

      <!-- base_link -->
      <link name="base_link">
        <visual name="base_link_visual">
          <geometry><box><size>0.3 0.2 0.1</size></box></geometry>
          <material>
            <ambient>0 0 1 1</ambient>
            <diffuse>0 0 1 1</diffuse>
          </material>
        </visual>
        <collision name="base_link_collision">
          <geometry><box><size>0.3 0.2 0.1</size></box></geometry>
        </collision>
        <inertial>
          <mass>2.0</mass>
          <inertia>
            <ixx>0.02</ixx><ixy>0</ixy><ixz>0</ixz>
            <iyy>0.02</iyy><iyz>0</iyz><izz>0.02</izz>
          </inertia>
        </inertial>
      </link>

      <!-- 左驱动轮（后轮） -->
      <link name="left_wheel">
        <pose> -0.12 -0.1 -0.05 1.5708 0 0 </pose> <!-- 向后偏移 -->
        <visual name="left_wheel_visual">
          <geometry><cylinder><radius>0.05</radius><length>0.02</length></cylinder></geometry>
          <material><ambient>0 0 0 1</ambient><diffuse>0 0 0 1</diffuse></material>
        </visual>
        <collision name="left_wheel_collision">
          <geometry><cylinder><radius>0.05</radius><length>0.02</length></cylinder></geometry>
        </collision>
        <inertial>
          <mass>0.2</mass>
          <inertia>
            <ixx>0.001</ixx><ixy>0</ixy><ixz>0</ixz>
            <iyy>0.001</iyy><iyz>0</iyz><izz>0.001</izz>
          </inertia>
        </inertial>
      </link>

      <!-- 右驱动轮（后轮） -->
      <link name="right_wheel">
        <pose> -0.12 0.1 -0.05 1.5708 0 0 </pose>
        <visual name="right_wheel_visual">
          <geometry><cylinder><radius>0.05</radius><length>0.02</length></cylinder></geometry>
          <material><ambient>0 0 0 1</ambient><diffuse>0 0 0 1</diffuse></material>
        </visual>
        <collision name="right_wheel_collision">
          <geometry><cylinder><radius>0.05</radius><length>0.02</length></cylinder></geometry>
        </collision>
        <inertial>
          <mass>0.2</mass>
          <inertia>
            <ixx>0.001</ixx><ixy>0</ixy><ixz>0</ixz>
            <iyy>0.001</iyy><iyz>0</iyz><izz>0.001</izz>
          </inertia>
        </inertial>
      </link>

      <!-- 前左万向轮（被动） -->
      <link name="caster_front_left">
        <pose> 0.12 -0.08 -0.05 0 0 0 </pose>
        <visual name="caster_fl_visual">
          <geometry><sphere><radius>0.03</radius></sphere></geometry>
          <material><ambient>0.5 0.5 0.5 1</ambient><diffuse>0.5 0.5 0.5 1</diffuse></material>
        </visual>
        <collision name="caster_fl_collision">
          <geometry><sphere><radius>0.03</radius></sphere></geometry>
          <!-- 减小摩擦，使其自由滚动 -->
          <surface>
            <friction>
              <ode>
                <mu>0.01</mu>
                <mu2>0.01</mu2>
              </ode>
            </friction>
          </surface>
        </collision>
        <inertial>
          <mass>0.05</mass>
          <inertia>
            <ixx>0.0001</ixx><ixy>0</ixy><ixz>0</ixz>
            <iyy>0.0001</iyy><iyz>0</iyz><izz>0.0001</izz>
          </inertia>
        </inertial>
      </link>

      <!-- 前右万向轮（被动） -->
      <link name="caster_front_right">
        <pose> 0.12 0.08 -0.05 0 0 0 </pose>
        <visual name="caster_fr_visual">
          <geometry><sphere><radius>0.03</radius></sphere></geometry>
          <material><ambient>0.5 0.5 0.5 1</ambient><diffuse>0.5 0.5 0.5 1</diffuse></material>
        </visual>
        <collision name="caster_fr_collision">
          <geometry><sphere><radius>0.03</radius></sphere></geometry>
          <surface>
            <friction>
              <ode>
                <mu>0.01</mu>
                <mu2>0.01</mu2>
              </ode>
            </friction>
          </surface>
        </collision>
        <inertial>
          <mass>0.05</mass>
          <inertia>
            <ixx>0.0001</ixx><ixy>0</ixy><ixz>0</ixz>
            <iyy>0.0001</iyy><iyz>0</iyz><izz>0.0001</izz>
          </inertia>
        </inertial>
      </link>

      <!-- camera_link -->
      <link name="camera_link">
        <pose>0.15 0 0.08 0 0 0</pose>
        <visual name="camera_link_visual">
          <geometry><box><size>0.05 0.05 0.03</size></box></geometry>
          <material><ambient>1 0 0 1</ambient><diffuse>1 0 0 1</diffuse></material>
        </visual>
        <collision name="camera_link_collision">
          <geometry><box><size>0.05 0.05 0.03</size></box></geometry>
        </collision>
        <inertial>
          <mass>0.1</mass>
          <inertia>
            <ixx>0.001</ixx><ixy>0</ixy><ixz>0</ixz>
            <iyy>0.001</iyy><iyz>0</iyz><izz>0.001</izz>
          </inertia>
        </inertial>
        <!-- 可能会用到多个摄像头传感器，这里命名为camera1 -->
        <sensor name="camera1" type="camera">
          <topic>/camera1</topic>
          <camera>
            <horizontal_fov>1.3962634</horizontal_fov>
            <image>
              <width>320</width>
              <height>240</height>
            </image>
            <clip>
              <near>0.1</near>
              <far>100</far>
            </clip>
          </camera>
            <always_on>1</always_on>
            <update_rate>24</update_rate>
            <visualize>true</visualize>
        </sensor>
      </link>

      <!-- Joints -->
      <joint name="left_wheel_joint" type="revolute">
        <parent>base_link</parent>
        <child>left_wheel</child>
        <axis><xyz>0 0 1</xyz></axis>
      </joint>

      <joint name="right_wheel_joint" type="revolute">
        <parent>base_link</parent>
        <child>right_wheel</child>
        <axis><xyz>0 0 1</xyz></axis>
      </joint>

      <!-- 万向轮使用 fixed 或 ball joint，但 Gz-sim 中常用 fixed + 低摩擦 sphere -->
      <joint name="caster_fl_joint" type="fixed">
        <parent>base_link</parent>
        <child>caster_front_left</child>
      </joint>

      <joint name="caster_fr_joint" type="fixed">
        <parent>base_link</parent>
        <child>caster_front_right</child>
      </joint>

      <joint name="base_to_camera" type="fixed">
        <parent>base_link</parent>
        <child>camera_link</child>
      </joint>

      <!-- 差速驱动插件（仅控制两个驱动轮） -->
      <plugin filename="libgz-sim-diff-drive-system.so" name="gz::sim::systems::DiffDrive">
        <left_joint>left_wheel_joint</left_joint>
        <right_joint>right_wheel_joint</right_joint>
        <wheel_separation>0.2</wheel_separation> <!-- 两驱动轮间距 -->
        <wheel_radius>0.05</wheel_radius>
        <topic>/model/my_robot/cmd_vel</topic>
        <odom_publish_frequency>20</odom_publish_frequency>
      </plugin>

    </model>
  </world>
</sdf>
```


1. **内置摄像头插件**：会自动将摄像头数据发布到 `/camera1` 话题

2. **运动控制插件**：`gz::sim::systems::DiffDrive` 插件会监听 `/cmd_vel` 话题来控制机器人运动

3. **数据流向**：
   - 摄像头 → `/camera1` 话题 → 你的视觉算法节点
   - 你的算法节点 → `/cmd_vel` 话题 → 机器人运动控制


```bash
# 启动文件
gz sim -r my_robot.sdf
```

### ros_gz_bridge

这个项目中涉及到2种通信信息格式的转换：

从ROS2_Gazebo流出的传感器数据，需要转为Python能处理的数据格式。

从算法节点流入ROS2_Gazebo的控制信息，需要是ROS2_Gazebo能理解的数据格式。

数据流向：ROS消息`sensor_msgs/Image` → cv_bridge → numpy数组 → cv2处理为控制结果 → 发布`geometry_msgs/Twist` → Gazebo

```bash
ros2 run ros_gz_bridge parameter_bridge \
  '/camera1/image@sensor_msgs/msg/Image[gz.msgs.Image' \
  '/model/my_robot/cmd_vel@geometry_msgs/msg/Twist]gz.msgs.Twist'
```


### 调试命令

```bash
# 查看活跃的话题
ros2 topic list

# 查看图像话题数据
ros2 topic echo /camera1/image
# 查看速度控制话题
ros2 topic echo /model/my_robot/cmd_vel

# 手动发送前进控制指令测试
ros2 topic pub /model/my_robot/cmd_vel geometry_msgs/Twist "linear: {x: 0.2, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}"

# 手动发送停止控制指令测试
ros2 topic pub /model/my_robot/cmd_vel geometry_msgs/Twist "linear: {x: 0.2, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 0.0}"
```


## 算法节点

### 代码示例

下面代码实现了一个视觉运动控制节点，从`/camera1`话题订阅图像数据，并处理后发布到`/cmd_vel`话题。


```python showLineNumbers
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Image
from cv_bridge import CvBridge
import cv2
import numpy as np
from geometry_msgs.msg import Twist

class VisualMotionController(Node):
    def __init__(self):
        super().__init__('visual_motion_controller')
        
        self.image_subscription = self.create_subscription(
            Image,
            '/camera1/image',  # 加/image
            self.process_and_control,
            10
        )
        
        self.velocity_publisher = self.create_publisher(
            Twist,
            '/model/my_robot/cmd_vel',
            10
        )

        self.bridge = CvBridge()
        self.move_speed = 0.2
        self.turn_speed = 0.5
        self.step = 0 # 计步器
        self.get_logger().info('视觉运动控制节点已启动')
        
    def process_and_control(self, image):
        self.get_logger().info('获取图像')
        image = self.cv_bridge.imgmsg_to_cv2(data, 'bgr8')
        self.step += 1

        cmd = Twist()
        if self.step < 100:
            cmd.linear.x = self.move_speed
            cmd.angular.z = 0.0
        elif self.step < 160:
            cmd.linear.x = 0.0
            cmd.angular.z = self.turn_speed
        else:
            self.step = 0

        self.velocity_publisher.publish(cmd)
        

def main(args=None):
    """主函数"""
    rclpy.init(args=args)
    
    # 创建视觉运动控制节点
    controller = VisualMotionController()
    
    try:
        # 启动节点
        rclpy.spin(controller)
    except KeyboardInterrupt:
        controller.get_logger().info('节点被用户中断')
    finally:
        # 发送停止指令
        stop_cmd = Twist()
        controller.velocity_publisher.publish(stop_cmd)
        # 清理资源
        controller.destroy_node()
        rclpy.shutdown()

```

启动命令：

```bash
# 编译工作空间（以learning_node为例）
colcon build --packages-select learning_node

# 启动节点（以learning_node为例）
ros2 run learning_node node_helloworld
```